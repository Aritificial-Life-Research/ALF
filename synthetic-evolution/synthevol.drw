# synthetic evolution - main program
#
# Daniel Margadant, Sereina Riniker, CBRG, 2005

# main data structure:
# evolution[organism#, gene#][mutRate, aa sequence, desc, id, organism, dna, cluster, indels, mutModel, rateChange, lastMutation]
#                             1        2            3     4   5         6    7        8       9         10          11
#                  mutRate = [domain start, domain end, mutrate], ...]

# initialisation (do not change, parameters are in separate file)

Set(quiet=true):
livingOrgs := 1;
evolTime := 0;
treeData := []:
treeData := append(treeData, []):   
treeEvo := '';
totD := 0; totL := 0;
spec := [];                   
GCratio := [];
timesteps := CreateArray(1..1);
geneR := [];
c := 0;
dupsOnLevel := [];
if specialAreas = true then
  ReadProgram(areaPath);
fi;


# get tree
if treeType = 'Custom' then
    tree := ReadTreeFile(treeFile):
elif treeType = 'BDTree' then
# old code. replace with Tanja Stadler's BD-Tree sampling method
#    tree := BirthDeathTree(birthRate, deathRate, maxTime, maxSpecies, not pruneDeadLineages):
#    if pruneDeadLineages then
#        labels := ListLivingLineages(tree):
#        tree := PruneTree(tree, labels):
#    fi:
    tree := BirthDeathTree(birthRate, deathRate, NSpecies, mutRate):
elif treeType = 'ToLSample' then
    D := GetAllDistMatrix():
    tree := GenRandomTree(D, NSpecies):
else
    error('no tree selected')
fi:
# calculation of the needed iteration steps
#rate := max(geneDuplRate, geneLossRate, lgtRate, lgtGRate,
#    aaGainRate, aaLossRate, 1);
if realseed = true then
    DB := ReadDb(realorganism);
    Nprot := DB[TotEntries];
    Naa := round(avg(seq(length(SearchTag('SEQ', Entry(e))), e=1..Nprot)));
else
    Naa := gammaLengthDist[1]*gammaLengthDist[2];
    Nprot := protStart;
fi:
#maxSteps := max(rate * max(Naa, Nprot), 1000);

# scale tree to branch lengths matching the number of iterations
#err := traperror(ScaleTree(tree, maxSteps)):
if scaleTree then
    err := traperror(ScaleTree(tree, mutRate)); ##### NEW: scale tree to height defined in parameters #####
    if err = lasterror then
        error('could not scale tree. make sure your tree is strictly bifurcating and all branches have a non-zero height.'):
    fi:
fi:
if not webRequest then
    printf('\ntree loaded\n'):
fi:

# build list of speciation time points and nodes from the tree
res := ListTimePoints(tree, '1'):
timePts := res[1]:
timePts := sort(timePts, timePts->timePts[2]):
for i to length(timePts) do
    curprefix1 := timePts[i,1].'.1';
    curprefix2 := timePts[i,1].'.2';
    curplen := length(curprefix1);
    for j from i+1 to length(timePts) do
        if length(timePts[j,1]) >= curplen and timePts[j, 1, 1..curplen] = curprefix1 then
            timePts[j,1] := timePts[i,1].timePts[j,1,curplen+1..-1]:
        elif length(timePts[j,1]) >= curplen and timePts[j, 1, 1..curplen] = curprefix2 then
            timePts[j,1] := string(i+1).timePts[j,1,curplen+1..-1]:
        fi:
    od:
od:

for i to length(timePts) do
    timePts[i,1] := atoi(timePts[i,1]):
od:

tptransp := transpose(timePts):
specTime := tptransp[2]:
specIndex := tptransp[1]:
if length(tptransp) = 3 then specModel := tptransp[3]: fi: # model switches

# if there's a list of duplication time points prepare it
# TODO: implement this kind of duplication (for version 2?)
if res[2] <> [] then
    dupTimePts := res[2]:
    dupTimePts := sort(dupTimePts, dupTimePts->dupTimePts[2]):
    for i to length(dupTimePts) do
        curprefix1 := dupTimePts[i,1].'.1';
        curprefix2 := dupTimePts[i,1].'.2';
        curplen := length(curprefix1);
        for j from i+1 to length(dupTimePts) do
            if length(dupTimePts[j,1]) >= curplen and dupTimePts[j, 1, 1..curplen] = curprefix1 then
                dupTimePts[j,1] := dupTimePts[j,1,1].dupTimePts[j,1,curplen+1..-1]:
            elif length(dupTimePts[j,1]) >= curplen and dupTimePts[j, 1, 1..curplen] = curprefix2 then
                dupTimePts[j,1] := string(i+1).dupTimePts[j,1,curplen+1..-1]:
            fi:
        od:
    od:
    
    for i to length(dupTimePts) do
        dupTimePts[i,1] := atoi(dupTimePts[i,1]):
    od:
    
    dtptransp := transpose(dupTimePts):
    dupTime := dtptransp[2]:
    dupIndex := dtptransp[1]:
    dupModel := dtptransp[3]: # model switches
else
    dupTime := []:
    dupIndex := []:
fi:

nextDupIndex := 1:
cSpecies := length(specTime) + 1:
    
#AAfactor := Nprot * Naa / maxSteps;
#Gfactor := Nprot / maxSteps;

if rateDistribution = 'Gamma' then
#    gammaRates := GammaRates(alphaG, areas) * mutRate / maxSteps:
    gammaRates := GammaRates(alphaG, areas):
    gammaRates := append(gammaRates, 1/DBL_MAX):
fi:

# assign each gene a substitution model
if realseed then
    malen := DB[TotEntries]:
else
    malen := protStart:
fi:
if length(modelAssignments) <> malen then
    modelProbs := modelAssignments:
    for i from 2 to length(modelProbs) do
        modelProbs[i] := modelProbs[i-1] + modelProbs[i]:
    od:
    modelAssignments := CreateArray(1..malen):
    for i to malen do
        r := Rand():
        for j to length(modelProbs) do
            if r <= modelProbs[j] then
                modelAssignments[i] := j:
                break:
            fi:
        od:
    od:
fi:

for i to length(substModels) do
    for j from 2 to length(substModels) do
        modelSwitchS[i, j] := modelSwitchS[i, j] + modelSwitchS[i, j-1]:
        modelSwitchD[i, j] := modelSwitchD[i, j] + modelSwitchD[i, j-1]:
    od:
od:
if not webRequest then
    printf('model assignments done\n'):
fi:

# loads real genome as first organism (if realseed is selected)
if realseed = true then # generates the first organism with real data
    evolution := []:
    evolution := append(evolution, CreateArray(1..DB[TotEntries], 1..11)):
    geneR := append(geneR, CreateArray(1..DB[TotEntries]));
    for i to DB[TotEntries] do
        protseq := SearchTag('SEQ', Entry(i));
        # switch for real domainfile
        if (specialAreas = true) then
	        for j to length(areaSet[i]) do
#	            areaSet[i, j, 3] := max(areaSet[i, j, 3] / maxSteps, 1/DBL_MAX);
	            areaSet[i, j, 3] := max(areaSet[i, j, 3], 1/DBL_MAX);
	        od;
            evolution[1, i, 1] := areaSet[i];
        else
            substModel := substModels[modelAssignments[i]]:
            if substModel[Name] = 'M0' then
                evolution[1, i, 1] := makeAreasOmega(substModel[Name], length(protseq)):
            elif substModel[Name][1] = 'M' then
                evolution[1, i, 1] := makeAreasOmega(substModel[Name], length(protseq), substModel[Params][3]):
            else
#                evolution[1, i, 1] := makeAreas(length(protseq), areas, mutRate, maxSteps, rateDistribution, motifFreq);
                evolution[1, i, 1] := makeAreas(length(protseq), areas, mutRate, rateDistribution, motifFreq);
            fi:
        fi;
        evolution[1, i, 3] := '1';
        evolution[1, i, 4] := i;
        evolution[1, i, 5] := '1';
        evolution[1, i, 6] := SearchTag('DNA', Entry(i));
        if protseq = 'AAA' and substModels[modelAssignments[i]][Type] <> 'nuc' then
            evolution[1, i, 2] := ProteinSeq(evolution[1, i, 6]):
        else
            evolution[1, i, 2] := protseq:
        fi:
        evolution[1, i, 2] := protseq;
        evolution[1, i, 7] := i;
        evolution[1, i, 8] := []:
        evolution[1, i, 9] := modelAssignments[i]:
        evolution[1, i, 10] := []:
        evolution[1, i, 11] := 0:
        geneR[1, i] := i;
    od:

# creates the first organism (if realseed is not selected)
else	
    evolution := []:
    evolution := append(evolution, CreateArray(1..protStart, 1..11)):
    geneR := append(geneR, CreateArray(1..protStart));
    for i to protStart do
        aaStart := max(minGeneLength, gammaLengthDist[2] * Rand(GammaDist(gammaLengthDist[1])));
        substModel := substModels[modelAssignments[i]]:
        if substModel[Name] = 'M0' then
            evolution[1, i, 1] := makeAreasOmega(substModel[Name], aaStart):
        elif substModel[Name][1] = 'M' then
            evolution[1, i, 1] := makeAreasOmega(substModel[Name], aaStart, substModel[Params][3]):
        else
            #printf('motifs %d - ', i):
#            evolution[1, i, 1] := makeAreas(aaStart, areas, mutRate, maxSteps, rateDistribution, motifFreq);
            evolution[1, i, 1] := makeAreas(aaStart, areas, mutRate, rateDistribution, motifFreq);
        fi:
        if substModel[Type] <> 'aa' then
            if substModel[Type] = 'nuc' and substModel[NeutralDNA] then
                evolution[1, i, 6] := Rand(DNA(aaStart));
            else
                evolution[1, i, 6] := Rand(CodingDNA(3 * aaStart));
            fi:
        fi:
        if substModel[Type] = 'aa' then
            evolution[1, i, 2] := Rand(Protein(aaStart)):
        elif substModel[Type] = 'codon' then
            evolution[1, i, 2] := ProteinSeq(evolution[1, i, 6]);
        else
            evolution[1, i, 2] := 'AAA'
        fi:
        evolution[1, i, 3] := '1';
        evolution[1, i, 4] := i;
        evolution[1, i, 5] := '1';
#        evolution[1, i, 7] := sprintf('%d',i);
        evolution[1, i, 7] := i;
        evolution[1, i, 8] := []:
        evolution[1, i, 9] := modelAssignments[i]:
        evolution[1, i, 10] := []:
        evolution[1, i, 11] := 0:
        geneR[1, i] := i;
    od:
fi:


maxID := length(evolution[1]);    # highest unique gene ID number
clusters := [seq([], maxID)]: # gene families

# definition of the GC amelioration for the first organism
if enableGCAmelioration then
    GCratio := append(GCratio, Rand(0.3..0.7)):
fi:

# write out DB file of first organism
DBoutAnc(evolution[1], 1, 1, 0);

# logfile header 
lastSpeciation := 1:
print('\n\nEvolution!\n\n');
OpenWriting(wdir.'/logfile.txt'); 
lprint('Synthetic evolution\n-------------------\n');
#printf('%i iteration steps\n', maxSteps);
printf('height of tree: %i\n', mutRate);
printf('first organism (%s): %i proteins with %i aa (average)\n', 
    If(realseed = true, 'biological sequences', 'artificial sequences'), 
    Nprot, Naa);
printf('Mutation rate: %.2f, Speciations: %i\n', 
    mutRate, cSpecies);
printf('Gene duplication rate: %.2f, transloc. Dupl.: %.2f, Gene loss rate: %.2f\n', 
    geneDuplRate, transDupl, geneLossRate);
printf('LGT rate: %.2f, LGT rate for groups: %.2f, LGT group size: %.2f\n', 
    lgtRate, lgtGRate, lgtGSize );
printf('Inversion rate: %.2f, max. Inversion group size: %.2f, inverted Translocation: %.2f\n',
    invers, invSize, invtrans);
printf('Translocation rate: %.2f, max. Translocation group size: %.2f\n',
    transloc, transSize);
printf('aa gain rate: %.3f, aa loss rate= %.3f\n\n', aaGainRate, aaLossRate);
#lprint('mutation rates: g <genenumber> : <domain 1>, <domain 2>, ...');
#for i to length(evolution[1]) do
#    printf('g %3i : ', i);
#    for j to length(evolution[1, i, 1]) do
#        printf('%.f ', evolution[1, i, 1, j, 3] * maxSteps);
#    od;
#    printf('\n');
#od;
lprint();

rateSum := geneDuplRate + geneLossRate + fusionRate + fissionRate + invers + transloc:
branches := EnumerateBranches(tree, timePts):
branches := sort(branches, x->x[3]):


ngenes := [length(evolution[1])]:
curT := 0:

events := [seq([], floor(mutRate/10)+1)]:

seind := 1:

for i to length(branches) do
    if seind > 1 then
        rateSum := rateSum + lgtRate + lgtGRate:
        totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:        
    else
        totalRate := ngenes[branches[i,1]] * rateSum:
    fi:
    curT := branches[i,2]:
    do
        curInt := Rand(Exponential(0,1/totalRate)):
        if curT + curInt > branches[i,3] then break fi:
        curT := curT + curInt:
        if seind > 1 then
            # select type of event
            cumProb := copy([geneDuplRate, geneLossRate, fusionRate, fissionRate, invers, transloc, lgtRate, lgtGRate]) * ngenes[branches[i,1]]:
            cumProb[7] := cumProb[7] + lgtRate:
            cumProb[8] := cumProb[8] + lgtGRate:
        else
            cumProb := copy([geneDuplRate, geneLossRate, fusionRate, fissionRate, invers, transloc]) * ngenes[branches[i,1]]:
        fi:
        for j from 2 to length(cumProb) do
            cumProb[j] := cumProb[j-1] + cumProb[j]:
        od:
        cumProb := cumProb / cumProb[-1]:
        r := Rand():
        event := 1:
        while r > cumProb[event] do event := event + 1 od:

        curInd := floor(curT/10)+1:

        if event = 1 then
            # gene duplication
            events[curInd] := append(events[curInd], [curT, branches[i,1], 'D']):
            ngenes[branches[i,1]] := ngenes[branches[i,1]] + 1:
            totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
        elif event = 2 then
            # gene loss
            events[curInd] := append(events[curInd], [curT, branches[i,1], 'L']):
            ngenes[branches[i,1]] := ngenes[branches[i,1]] - 1:
            totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
        elif event = 7 then
            # lgt
            events[curInd] := append(events[curInd], [curT, branches[i,1], 'LGT']):
            ngenes[branches[i,1]] := ngenes[branches[i,1]] + 1:
            totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
        elif event = 8 then
            # group lgt
            numg := Rand(2..lgtGSize):
            events[curInd] := append(events[curInd], [curT, branches[i,1], 'LGTG', numg]):
            ngenes[branches[i,1]] := ngenes[branches[i,1]] + numg:
            totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
        elif event = 3 then
            # fusion
            events[curInd] := append(events[curInd], [curT, branches[i,1], 'FU']):
            ngenes[branches[i,1]] := ngenes[branches[i,1]] - 1:
            totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
        elif event = 4 then
            # fission
            events[curInd] := append(events[curInd], [curT, branches[i,1], 'FI']):
            ngenes[branches[i,1]] := ngenes[branches[i,1]] + 1:
            totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
        elif event = 5 then
            # inversion
            events[curInd] := append(events[curInd], [curT, branches[i,1], 'IV']):
        elif event = 6 then
            # transloc
            events[curInd] := append(events[curInd], [curT, branches[i,1], 'TL']):
        else
            error('unknown event!'):
        fi:
    od:
#    printf('seind: %A, length(timePts): %A,  branches[i,1]: %A, timePts[seind,1]: %A, branches[i,3]: %A, timePts[seind,2]: %A,\n',seind, length(timePts), branches[i,1], timePts[seind,1], branches[i,3], timePts[seind,2]):
    if seind <= length(timePts) and branches[i,1] = timePts[seind,1] and branches[i,3] = timePts[seind,2] then
        ngenes := append(ngenes, copy(ngenes[branches[i,1]])):
        seind := seind + 1:
    fi: 
od:

for i to length(timePts) do
    curInd := floor(timePts[i,2]/10)+1:
    events[curInd] := append(events[curInd], [timePts[i,2], timePts[i,1], 'S']):
od:

for i to length(events) do
    events[i] := sort(events[i], x->x[1]):
od:

if indelModel = 'ZIPF' then
    meanGapLength := MeanGapLength(indelModel, maxIndelLength, [Z_c]):
elif indelModel = 'QG' then
    meanGapLength := MeanGapLength(indelModel, maxIndelLength, [QG_c, QG_t]):
elif indelModel = 'NEGBIN' then
    meanGapLength := MeanGapLength(indelModel, maxIndelLength, [NB_r, NB_q]):
else
    meanGapLength := MeanGapLength(indelModel, maxIndelLength, indelVector):
fi:

for i to length(events) do
    for j to length(events[i]) do
        cure := events[i,j,3]:
        if cure = 'D' then
            # gene duplication
            PerformGeneDuplication(events[i,j,2], events[i,j,1]):
        elif cure = 'L' then
            # gene loss
            PerformGeneLoss(events[i,j,2], events[i,j,1]):
        elif cure = 'LGT' then
            # LGT
            PerformLGT(events[i,j,2], events[i,j,1]):
        elif cure = 'LGTG' then
            # group LGT
            PerformLGTG(events[i,j,2], events[i,j,1], events[i,j,4]):
        elif cure = 'FU' then
            # gene fusion
            PerformFusion(events[i,j,2], events[i,j,1]):
        elif cure = 'FI' then
            # gene fission
            PerformFission(events[i,j,2], events[i,j,1]):
        elif cure = 'IV' then
            # inversion
            PerformInversion(events[i,j,2]):
        elif cure = 'TL' then
            # translocation
            PerformTranslocation(events[i,j,2]):
        elif cure = 'S' then
            # speciation
            PerformSpeciation(events[i,j,2], events[i,j,1]):
        else
            error('unknown event!'):
        fi:
    od:
od:

OpenWriting(previous);
lprint('...main calculation finished.');


# saves real tree, updates all organisms
branchesSet := {op(branches)}:
for i to length(branchesSet) do
    treeEvo[op(treeData[branchesSet[i,1]])]:=Leaf('SE'.sprintf('%03d', branchesSet[i,1]), branchesSet[i,3]); 
od:
DrawTree(treeEvo, ArcRadial, OrderLeaves=LeftHeavy, Legend, 
    Title = 'synthetic evolution');
TimedCallSystem('mv temp.ps '.wdir.'/RealTree.ps', 2);
OpenWriting(wdir . 'RealTree.drw');
printf('RealTree := %a;\n', treeEvo);
OpenWriting(previous);
leafHeights := CreateArray(1..livingOrgs, 0):
for j to livingOrgs do
    org := branches[-j,1]:
    leafHeights[org] := branches[-j,3]:
    for g to length(evolution[org]) do
        seqmutation(org, g, branches[-j,3]);
    od:
od:
lprint('...real genome tree saved.');

# calculates total number of lgt and duplication and gathers gene families
for i to livingOrgs do
    for j to length(evolution[i]) do
    	if SearchString('D', evolution[i, j, 3]) > -1 then
	        totD := totD + 1;
    	fi;
	    if SearchString('L', evolution[i, j, 3]) > -1 then
	        totL := totL + 1;
    	fi;
    	clusters[evolution[i,j,7]] := append(clusters[evolution[i,j,7]], [i,j]):
    od:
od:

# create MSAs
for i to length(clusters) do
    CreateRealMSA(clusters[i], evolution):
od:

# create gene trees
geneTrees := CreateGeneTrees(clusters, evolution, mutRate, leafHeights):

# store orthologs for each pair of genes
WriteOrthologs(geneTrees, livingOrgs):

# logfile footer, DB output, GenomeSummaries
OpenAppending(wdir.'/logfile.txt');
printf('\n\n\n\%i species generated\n', livingOrgs);
printf('%.0f gene duplications and %.0f lgt events\n', totD, totL);
printf('\nGC amelioration:');
printf('\norganism #\ttarget GC content\tinitialized GC ratio\n'); 
for i to length(GCratio) do
    printf('\norganism %i\t%.2f\t\t%.2f', 
	i, GCratio[i], calGCcont(evolution[i])); 
od;
OpenWriting(previous);

DBout():
DBoutFASTA():
lprint('...genome DBs saved.');

if webRequest then
    summariesString := wdir.'/DB/Summaries.drw';
else
    summariesString := wdir.'/Summaries.drw':
fi:
OpenWriting(summariesString);
printf('GenomeSummaries := table():\ngenomes := []:\n');
for i to livingOrgs do
    OpenWriting(previous);
    orgname := sprintf('SE%03d', i):
    DB := ReadDb(wdir.dbdir.orgname.'.db'):
    OpenAppending(summariesString);
    printf('genomes := append(genomes, %s):\n', orgname):
    printf('GenomeSummaries[%s] :=', orgname );
    dprint(copy(GenomeSummary(DB)));
    printf(':\n');
od:
OpenWriting(previous);
lprint('\n   simulation finished!'):


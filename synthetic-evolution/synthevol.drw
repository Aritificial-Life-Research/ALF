# synthetic evolution - main program
#
# Daniel Margadant, Sereina Riniker, CBRG, 2005

# main data structure:
# evolution[organism#, gene#][mutRate, aa sequence, desc, id, organism, dna, cluster]
#                             1        2            3     4   5         6    7
#                  mutRate = [domain start, domain end, mutrate], ...]


# initialisation (do not change, parameters are in separate file)
livingOrgs := 1;
evolTime := 0;
treeData := []:
treeData := append(treeData, []):   
treeEvo := '';
totD := 0; totL := 0;
spec := [];                   
GCratio := [];                      
GCplus := GCBiasMatrix(50);
GCminus := GCBiasMatrix(-50);
timesteps := CreateArray(1..1);
geneR := [];
c := 0;
if specialAreas = true then
  ReadProgram(areaPath);
fi;

# calculation of the needed iteration steps
rate := max(geneDuplRate, geneLossRate, lgtRate, lgtGRate,
    aaGainRate, aaLossRate, 1);
if realseed = true then
    DB := ReadDb(realorganism);
    Nprot := DB[TotEntries];
    Naa := round(avg(seq(length(SearchTag('SEQ', Entry(e))), e=1..Nprot)));
else
    Naa := (aaStart1+aaStart2)/2;
    Nprot := protStart;
fi;
maxSteps := max(rate * max(Naa, Nprot), 1000);

# calculation for the speciation time points
minSpecTime := round(maxSteps / 5 / cSpecies);
specTime := {seq(Rand(1..maxSteps), k=1..cSpecies - 1)};
for i to cSpecies - 2 do
    if specTime[i + 1] - specTime[i] < minSpecTime then
        specTime[i + 1] := specTime[i] + minSpecTime;
    fi;
od:
if specTime[-1] > maxSteps then maxSteps := specTime[-1]; fi;
    
    
AAfactor := Nprot * Naa / maxSteps;
Gfactor := Nprot / maxSteps;

# loads real genome as first organism (if realseed is selected)
if realseed = true then # generates the first organism with real data
    evolution := [];
    evolution := append(evolution, CreateArray(1..DB[TotEntries], 1..7)):
    geneR := append(geneR, CreateArray(1..DB[TotEntries]));
    for i to DB[TotEntries] do
        protseq := SearchTag('SEQ', Entry(i));
        # switch for real domainfile
        if (specialAreas = true) then
	        for j to length(areaSet[i]) do
	            areaSet[i, j, 3] := max(areaSet[i, j, 3] / maxSteps, 1/DBL_MAX);
            od;
            evolution[1, i, 1] := areaSet[i];
        else
            evolution[1, i, 1] := makeAreas(length(protseq), areas, 
    		mutRate, maxSteps);
        fi;
        evolution[1, i, 2] := protseq;
        evolution[1, i, 3] := '1';
        evolution[1, i, 4] := i;
        evolution[1, i, 5] := '1';
        evolution[1, i, 6] := SearchTag('DNA', Entry(i));
        evolution[1, i, 7] := sprintf('%d',i);
        geneR[1, i] := i;
    od:

# creates the first organism (if realseed is not selected)
else	
    evolution := []:
    evolution := append(evolution, CreateArray(1..protStart, 1..7)):
    geneR := append(geneR, CreateArray(1..protStart));
    for i to protStart do
        aaStart := Rand(aaStart1..aaStart2);
        evolution[1, i, 1] := makeAreas(aaStart, areas, mutRate, maxSteps);
        evolution[1, i, 6] := Rand(CodingDNA(3 * aaStart));
        evolution[1, i, 2] := ProteinSeq(evolution[1, i, 6]);
        evolution[1, i, 3] := '1';
        evolution[1, i, 4] := i;
        evolution[1, i, 5] := '1';
        evolution[1, i, 7] := sprintf('%d',i);
        geneR[1, i] := i;
    od:
fi;
maxID := length(evolution[1]);    # highest unique gene ID number


# definition of the GC amelioration for the first organism
gcrat := calGCcont(evolution[1]);
gcw := Rand(30..70);
if gcrat > gcw then
    GCratio := append(GCratio, [gcw, 'minus']);        
elif gcrat < gcw then
    GCratio := append(GCratio, [gcw, 'plus']);
else GCratio := append(GCratio, [gcw, '0']);
fi;
DBoutAnc(evolution[1], 1, 1, 1);


# logfile header 
lastSpeciation := 1:
print('\n\nEvolution!\n\n');
OpenWriting(wdir.'logfile.txt'); 
lprint('Synthetic evolution\n-------------------\n');
printf('%i iteration steps\n', maxSteps);
printf('first organism (%s): %i proteins with %i aa (average)\n', 
    If(realseed = true, 'biological sequences', 'artificial sequences'), 
    Nprot, Naa);
printf('Mutation rate: %.2f, Speciations: %i\n', 
    mutRate, cSpecies);
printf('Gene duplication rate: %.2f, transloc. Dupl.: %.2f, Gene loss rate: %.2f\n', 
    geneDuplRate, transDupl, geneLossRate);
printf('LGT rate: %.2f, LGT rate for groups: %.2f, LGT group size: %.2f\n', 
    lgtRate, lgtGRate, lgtGSize );
printf('Inversion rate: %.2f, max. Inversion group size: %.2f, inverted Translocation: %.2f\n',
    invers, invSize, invtrans);
printf('Translocation rate: %.2f, max. Translocation group size: %.2f\n',
    transloc, transSize);
printf('aa gain rate: %.3f, aa loss rate= %.3f\n\n', aaGainRate, aaLossRate);
lprint('mutation rates: g <genenumber> : <domain 1>, <domain 2>, ...');
for i to length(evolution[1]) do
    printf('g %3i : ', i);
    for j to length(evolution[1, i, 1]) do
        printf('%.f ', evolution[1, i, 1, j, 3] * maxSteps);
    od;
    printf('\n');
od;
lprint();
    
    
# main evolution loop 
while evolTime <= maxSteps do
    evolTime := evolTime + 1:
    if (c + 1) * round(maxSteps / 100) = evolTime then
        c := c + 1;
        OpenWriting(previous);
        printf('  evolution progress in time steps:\t%i%%\t (%i of %i)\n', 
            c, evolTime, maxSteps);
        OpenAppending(wdir.'logfile.txt');
    fi;
    
    # loop over all current existing organisms
    for j to livingOrgs do
        
        # indel: aa gain
        if 100 * Rand() < (aaGainRate * AAfactor) then
            # calculates sum of all domain/gene probabilities
            indelSum := indelPos := 0;
            for k to length(evolution[j]) do
                for m to length(evolution[j, k, 1]) do
                    indelSum := indelSum + evolution[j, k, 1, m, 3] * (1 + 
                    evolution[j, k, 1, m, 2] - evolution[j, k, 1, m, 1]);
                od;
            od;
            # assignes a random value between 0..indelSum
            indelPos := Rand() * indelSum;
            # finds the domain/gene for indel event
            h := l := 0;
            k := 1; 
            while h < indelPos do
                l := l + 1;
                if l > length(evolution[j, k, 1]) then 
                    l := 1; 
                    k := k + 1; 
                fi;
                h := h + evolution[j, k, 1, l, 3] * (1 +
                    evolution[j, k, 1, l, 2] - evolution[j, k, 1, l, 1]);
            od;
            # finds the indel length out of a Zipfian distribution
            # (exponent 1.821 comes from (Chang and Benner 2004))
            L := 0; r := 1;
            lr := Rand();
            while r > lr and L < maxIndelLength do
                L := L + 1;
                r := L^(-1.821);
            od;
            indelLength := L - 1;
            # searches a random start position for the insertion
            indelStart := 3 * Rand(evolution[j, k, 1, l, 1]..
                evolution[j, k, 1, l, 2]);
            # performs aa gain
            for h from indelStart to indelStart + 3 * indelLength by 3 do
                dna_value := Rand(CodingDNA(3));
                if h = 0 then
                    evolution[j, k, 6] := dna_value.string(evolution[j, k, 6]);
                elif h = length(evolution[j, k, 6]) then
                    evolution[j, k, 6] := string(evolution[j, k, 6]).dna_value;
                else
                    evolution[j, k, 6] := string(evolution[j, k,6])
                    [1..h].dna_value.string(evolution[j, k, 6])[h + 1..-1];
                fi;
                evolution[j, k, 1] := updateBorder(evolution[j, k, 1],
                    (h / 3), 'insert');
            od:
            evolution[j, k, 2] := ProteinSeq(evolution[j, k, 6]);
        fi;


        # indel: aa loss 
        if 100 * Rand() < (aaLossRate * AAfactor) then
            # calculates sum of all domain/gene probabilities
            indelSum := indelPos := 0;
            for k to length(evolution[j]) do
                for m to length(evolution[j, k, 1]) do
                    indelSum := indelSum + evolution[j, k, 1, m, 3] * (1 +
                    evolution[j, k, 1, m, 2] - evolution[j, k, 1, m, 1]);
                od;
            od;
            # assignes a random value between 0..indelSum
            indelPos := Rand() * indelSum;
            # finds the domain/gene for indel event 
            h := l := 0;
            k := 1;
            while h < indelPos do
                l := l + 1;
                if l > length(evolution[j, k, 1]) then
                    l := 1;
                    k := k + 1;
                fi;
                h := h + evolution[j, k, 1, l, 3] * (1 +
                    evolution[j, k, 1, l, 2] - evolution[j, k, 1, l, 1]);
            od;
            # finds the indel length out of a Zipfian distribution
            # (exponent 1.821 comes from (Chang and Benner 2004))
            L := 0; r := 1;
            lr := Rand();
            while r > lr and L < maxIndelLength do
                L := L + 1;
                r := L^(-1.821);
            od;
            indelLength := L - 1;
            # searches a random start position for the deletion
            L := min(L, evolution[j, k, 1, l, 2] - evolution[j, k, 1, l, 1]);
            indelStart := 3 * Rand(evolution[j, k, 1, l, 1]..
                evolution[j, k, 1, l, 2] - L);
            # performs aa loss 
            if L = 0 then 
                evolution[j, k, 6] := 
                    string(evolution[j, k, 6])[1..indelStart - 3].
                    string(evolution[j, k, 6])[indelStart + 1..-1];
                evolution[j, k, 1] := updateBorder(evolution[j, k, 1],
                    indelStart / 3, 'delet');
            fi;    
            for h from indelStart + 3 * L to indelStart + 3 by -3 do
                if h = length(evolution[j, k, 6]) then
                    evolution[j, k, 6] := string(evolution[j, k, 6])[1..-4];
                else
                    evolution[j, k, 6] :=
                    string(evolution[j, k, 6])[1..h - 3].
                    string(evolution[j, k, 6])[h + 1..-1];
                fi;
                evolution[j, k, 1] := updateBorder(evolution[j, k, 1],
                    (h / 3), 'delet');
            od:
            evolution[j, k, 2] := ProteinSeq(evolution[j, k, 6]);
        fi;


        # gene duplication
        if 100 * Rand() < (geneDuplRate * Gfactor) then
    	    ndupl := Rand(1..numberDupl);
            geneSource := Rand(1..length(evolution[j]) - ndupl + 1); 
            seqmutation(j, max(1, evolTime - timesteps[j]));
            timesteps[j] := evolTime;
            for k from 0 to ndupl - 1 do 
                evolution[j] := append(evolution[j], 
                    copy(evolution[j, geneSource + k]));
                evolution[j, -1, 3] := evolution[j, -1, 3].'-('.copy(evolution
                    [j, geneSource + k, 4]).'D'.evolTime.')'.j;
                maxID := maxID + 1;
				# update clusters
				evolution[j, -1, 7] := evolution[j,-1,7] . '.2';
				evolution[j, geneSource+k, 7] := evolution[j,geneSource+k,7] . '.1';
				
                evolution[j, -1, 4] := maxID;
                for l to length(evolution[j, -1, 1]) do
                    evolution[j, -1, 1][l, 3] := 
                        evolution[j, -1, 1][l, 3] * 1.5;
                od;
                geneR[j] := append(geneR[j], evolution[j, -1, 4]);
                printf('time %0004i: gene duplication in organism %i with gene'.
                    ' %i, now gene %i\n', evolTime, j, evolution[j, 
                    geneSource + k, 4], evolution[j, -1, 4]);
                h := evolution[j, geneSource + k, 4];
            od;
            # gene rearrangement
            if 100 * Rand() < transDupl then
                place := Rand(1..length(geneR[j]) - 1 - ndupl);
                transLoc(j, place, SearchArray(evolution[j, -ndupl, 4], 
                    abs(geneR[j])), ndupl);
            else
                place := SearchArray(evolution[j, geneSource + ndupl - 1, 4], 
                    abs(geneR[j]));
                transLoc(j, place, SearchArray(evolution[j, -ndupl, 4], 
                    abs(geneR[j])), ndupl);
            fi;
        fi;
        
        # gene loss	    
        if 100 * Rand() < (geneLossRate * Gfactor) then
            geneSource := trunc(Rand() * length(evolution[j])) + 1;
            seqmutation(j, max(1, evolTime - timesteps[j]));
            timesteps[j] := evolTime;
            printf ('time %0004i: gene loss in organism %i with gene %i\n', 
                evolTime, j, evolution[j, geneSource, 4]);
	    # gene rearrangement
            deleteItem(j, SearchArray(evolution[j, geneSource, 4], 
                abs(geneR[j])));
	    # deleting the gene
            if geneSource = 1 then
                evolution[j] := evolution[j][2..-1];
            elif geneSource = length(evolution[j]) then
                evolution[j] := evolution[j][1..-2];
            else 
                evolution[j] := [op(evolution[j][1..geneSource - 1]),
                    op(evolution[j][geneSource + 1..-1])];
            fi;
        fi;

        # inversion of single or multiple genes
        if 100 * Rand() < (invers * Gfactor) then
            iSize := Rand(1..invSize);
                target := Rand(1..length(geneR[j]) - iSize - 1);
            if iSize = 1 then
                geneR[j, target] := -geneR[j, target];
            else
                groupInvert(j, target, iSize);
            fi;
            # inverted translocation
            if 100 * Rand() < invtrans then
                place := Rand(1..length(geneR[j]) - iSize - 1);
                transLoc(j, place, target, iSize);
            fi;
        fi;

        # translocation of single or multiple genes
        if 100 * Rand() < (transloc * Gfactor) then
            tSize := Rand(1..transSize);
            target := Rand(1..length(geneR[j]) - tSize - 1);
            place := Rand(1..length(geneR[j]) - tSize - 1);
            transLoc(j, place, target, tSize);
        fi;

        # lateral gene transfer of single genes
        if 100 * Rand() < (lgtRate * Gfactor) and livingOrgs > 1 then

            # lgt - orthologous replacement
            if 100 * Rand() < orthRep then
                # finds donor (recipient is current organism j)
                donors := {seq(i, i = 1..livingOrgs)} minus {j}; 
                orgDonor := Rand(donors);
                seqmutation(j, max(1, evolTime - timesteps[j]));
                timesteps[j] := evolTime;
                seqmutation(orgDonor, max(1, evolTime - timesteps[orgDonor]));
                timesteps[orgDonor] := evolTime;
                gd1 := {op(transpose(evolution[orgDonor])[4])};
                gd2 := {op(transpose(evolution[j])[4])};
                gD := Rand(gd1 intersect gd2);
                geneSource := SearchArray(gD, transpose(evolution[j])[4]);
                geneDonor := SearchArray(gD, transpose(evolution[orgDonor])[4]);
                # copies entry and updates description
                evolution[j] := append(evolution[j], 
                    copy(evolution[orgDonor, geneDonor]));
                evolution[j, -1, 3] := evolution[j, -1, 3].'-'.orgDonor.'('.
                    copy(evolution[orgDonor, geneDonor, 4]).'Lo'.evolTime.')'.j;
                maxID := maxID + 1;
                evolution[j, -1, 4] := maxID;
                evolution[j, -1, 7] := sprintf('%d',maxID); # new cluster 
                evolution[j, -1, 5] := copy(evolution[j, -2, 5]);
                printf ('time %0004i: lgt from organism %i with gene %i to '.
                    'organism %i, now gene %i\n', evolTime, orgDonor, 
                    evolution[orgDonor, geneDonor, 4], j, evolution[j, -1, 4]);
                printf('\torthologues replacement, gene %i in organism %i '.
                    'deleted\n', evolution[j, geneSource, 4], j);
                geneR[j, SearchArray(gD, abs(geneR[j]))] := maxID;
                # deletes own version of gene in recipient
                if geneSource = 1 then
                    evolution[j] := evolution[j][2..-1];
                elif geneSource = length(evolution[j]) then
                    evolution[j] := evolution[j][1..-2];
                else
                    evolution[j] := [op(evolution[j][1..geneSource - 1]),
                        op(evolution[j][geneSource + 1..-1])];
                fi;


            # lgt - novel gene acquisition
            else
                # finds donor (recipient is current organism j)
                donors := {seq(i, i = 1..livingOrgs)} minus {j};
                orgDonor := Rand(donors);
                seqmutation(j, max(1, evolTime - timesteps[j]));
                timesteps[j] := evolTime;
                seqmutation(orgDonor, max(1, evolTime - timesteps[orgDonor]));
                timesteps[orgDonor] := evolTime;
                geneDonor := trunc(Rand() * 
                    length(evolution[orgDonor])) + 1;
                # copies entry and updates description
                evolution[j] := append(evolution[j], 
                    copy(evolution[orgDonor, geneDonor]));
                evolution[j, -1, 3] := evolution[j, -1, 3].'-'.orgDonor.'('.
                    copy(evolution[orgDonor, geneDonor, 4]).'L'.evolTime.')'.j;
                maxID := maxID + 1;
                evolution[j, -1, 4] := maxID; 
                evolution[j, -1, 7] := sprintf('%d',maxID); # new cluster 
				evolution[j, -1, 5] := copy(evolution[j, -2, 5]);
                printf ('time %0004i: lgt from organism %i with gene %i '.
                    'to organism %i, now gene %i\n', evolTime, orgDonor, 
                    evolution[orgDonor, geneDonor, 4], j, evolution[j, -1, 4]);
                # gene rearrangement
                geneR[j] := append(geneR[j], maxID);
                place := Rand(0..length(geneR[j]) - 1);
                transLoc(j, place, length(geneR[j]), 1);
            fi;
        fi;
        
        # lateral gene transfer	of multiple genes
        if 100 * Rand() < (lgtGRate * Gfactor) and livingOrgs > 1 then
            # finds donor (recipient is current organism j)
            donors := {seq(i, i = 1..livingOrgs)} minus {j};
            orgDonor := Rand(donors);
            seqmutation(j, max(1, evolTime - timesteps[j]));
            timesteps[j] := evolTime;
            seqmutation(orgDonor, max(1, evolTime - timesteps[orgDonor]));
            timesteps[orgDonor] := evolTime;
            geneDonor := trunc(Rand() * (length(evolution[orgDonor]) - 
                lgtGSize)) + 1;	
            source := geneDonor;
            # copies entries for lgtGsize proteins
            for i to lgtGSize do
                evolution[j] := append(evolution[j], 
                    copy(evolution[orgDonor, geneDonor]));
                evolution[j, -1, 3] := 
                    evolution[j, -1, 3].'-'.orgDonor.'('.copy(evolution
                    [orgDonor, geneDonor, 4]).'L'.evolTime.')'.j;
                maxID := maxID + 1;
                evolution[j, -1, 4] := maxID;
                evolution[j, -1, 5] := copy(evolution[j, -2, 5]);
                printf ('time %0004i: lgt from organism %i with gene %i '.
                    'to organism %i, now gene %i\n', 
                evolTime, orgDonor, evolution[orgDonor, geneDonor, 4],
                    j, evolution[j, -1, 4]);
                geneR[j] := append(geneR[j], evolution[j, -1, 4]);
                geneDonor := geneDonor + 1;
            od;
            # gene rearrangement
            place := Rand(0..length(geneR[j]) - lgtGSize - 1);
            transLoc(j, place, length(geneR[j]) - lgtGSize + 1, lgtGSize);
        fi;
    od;

        
    # speciation
    if member(evolTime, specTime) then
        # organism which will have offspring is randomly chosen
        orgSource := trunc(Rand() * livingOrgs) + 1;
        seqmutation(orgSource, max(1, evolTime - timesteps[orgSource]));
        timesteps[orgSource] := evolTime;
        timesteps := append(timesteps, evolTime);
        evolution := append(evolution, copy(evolution[orgSource]));
        geneR := append(geneR, copy(geneR[orgSource]));
        livingOrgs := livingOrgs + 1;
        # updates history in gene descriptions
        for l to length(evolution[livingOrgs]) do
            evolution[livingOrgs, l, 5] :=	
                evolution[orgSource, l, 5].'-('.evolTime.')'.livingOrgs;
            evolution[livingOrgs, l, 3] :=
                evolution[orgSource, l, 3].'-('.evolTime.')'.livingOrgs;
        od;
        spec := append(spec, ['SE'.sprintf('%03i', orgSource), 
            'SE'.sprintf('%03i', livingOrgs), evolTime]);
        # defines new GC amelioration direction for new species
        gcrat := calGCcont(evolution[livingOrgs]); 
        gcw := Rand(30..70);
        if gcrat > gcw then
            GCratio := append(GCratio, [gcw, 'minus']);
        elif gcrat < gcw then
            GCratio := append(GCratio, [gcw, 'plus']);
        else GCratio := append(GCratio, [gcw, '0']);
        fi;
        # creates a new leaf in the real tree
        treeData := append(treeData, []);
        d := evolTime;
        if treeData[orgSource] = [] then
            treeEvo[] := Tree(Leaf(orgSource, d),
                d, Leaf(livingOrgs, d));
        else
            treeEvo[op(treeData[orgSource])] := Tree(Leaf(orgSource, d),
                d, Leaf(livingOrgs, d));
        fi;
        treeData[livingOrgs] := append(copy(treeData[orgSource]), Right);
        treeData[orgSource] := append(copy(treeData[orgSource]), Left);
        lastSpeciation := evolTime;
        printf ('time %0004i: speciation event of organism %i to organism '.
            '%i, GC content: %.2f%%\n', evolTime, orgSource, livingOrgs, gcrat);
        OpenWriting(previous);
        printf('species %i was created at time %i\n', livingOrgs, evolTime);
    	DBoutAnc(evolution[livingOrgs], orgSource, livingOrgs, evolTime);
        OpenAppending(wdir.'logfile.txt');
    fi;
od:
OpenWriting(previous);
lprint('...main calculation finished.');


# saves real tree, updates all organisms
for i to livingOrgs do
    treeEvo[op(treeData[i])]:=Leaf('SE'.sprintf('%03d', i), evolTime); 
od:
DrawTree(treeEvo, ArcRadial, OrderLeaves=LeftHeavy, Legend, 
    Title = 'synthetic evolution');
TimedCallSystem('mv temp.ps '.wdir.'RealTree.ps', 2);
OpenWriting(wdir . 'RealTree.drw');
printf('RealTree := %a;\n', treeEvo);
OpenWriting(previous);
for j to livingOrgs do
    seqmutation(j, max(1, evolTime - timesteps[j]));
od:
lprint('...real genome tree saved.');

# calculates total number of lgt and duplication
for i to livingOrgs do
    for j to length(evolution[i]) do
    	if SearchString('D', evolution[i, j, 3]) > -1 then
	        totD := totD + 1;
    	fi;
	    if SearchString('L', evolution[i, j, 3]) > -1 then
	        totL := totL + 1;
    	fi;
    od:
od:

# logfile footer, DB output, GenomeSummaries
OpenAppending(wdir.'logfile.txt');
printf('\n\n\n\%i species generated\n', livingOrgs);
printf('%.0f gene duplications and %.0f lgt events\n', totD, totL);
printf('\nGC amelioration:');
printf('\norganism #\ttarget GC content\tinitialized GC ratio'); 
for i to length(GCratio) do
    printf('\norganism %i\t%.2f\t\t%.2f', 
	i, GCratio[i,1], calGCcont(evolution[i])); 
od;
OpenWriting(previous);

DBout():
DBoutFASTA():
lprint('...genome DBs saved.');

OpenWriting(wdir.'Summaries.drw');
printf('GenomeSummaries := table():\ngenomes := []:\n');
for i to livingOrgs do
    OpenWriting(previous);
    orgname := sprintf('SE%03d', i):
    DB := ReadDb(wdir.dbdir.orgname.'.db'):
    OpenAppending(wdir.'Summaries.drw');
    printf('genomes := append(genomes, %s):\n', orgname):
    printf('GenomeSummaries[%s] :=', orgname );
    dprint(copy(GenomeSummary(DB)));
    printf(':\n');
od:
OpenWriting(previous);
lprint('\n   simulation finished!'):


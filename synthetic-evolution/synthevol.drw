# synthetic evolution - main program
#
# Daniel Margadant, Sereina Riniker, CBRG, 2005

# main data structure:
# evolution[organism#, gene#][mutRate, aa sequence, desc, id, organism, dna, cluster, indels, mutModel, rateChange, lastMutation]
#                             1        2            3     4   5         6    7        8       9         10          11
#                  mutRate = [domain start, domain end, mutrate], ...]

# initialisation (do not change, parameters are in separate file)

Set(quiet=true):
livingOrgs := 1;
evolTime := 0;
treeData := []:
treeData := append(treeData, []):   
treeEvo := '';
lgtNum := 0:
totD := 0; totL := 0;
spec := [];
timesteps := CreateArray(1..1);
geneR := [];
c := 0;
dupsOnLevel := [];
if specialAreas = true then
  ReadProgram(areaPath);
fi;
if amongGeneDistr = 'Custom' then
    customRates := parse(ReadRawFile(aGPath)):
fi:

# assign variables for features that are turned off
if not assigned(geneDuplRate) then
    geneDuplRate := 0:
fi:
if not assigned(transDupl) then
    transDupl := 0:
fi:
if not assigned(fusionDupl) then
    fusionDupl := 0:
fi:
if not assigned(fissionDupl) then
    fissionDupl := 0:
fi:
if not assigned(P_pseudogene) then
    P_pseudogene := 0;
fi:
if not assigned(P_neofunc) then
    P_neofunc := 0;
fi:
if not assigned(P_subfunc) then
    P_subfunc := 0;
fi:
if not assigned(geneLossRate) then
    geneLossRate := 0:
fi:
if not assigned(lgtRate) then
    lgtRate := 0:
fi:
if not assigned(lgtGRate) then
    lgtGRate := 0:
fi:
if not assigned(invers) then
    invers := 0:
fi:
if not assigned(transloc) then
    transloc := 0:
fi:
if not assigned(aaGainRate) then
    aaGainRate := 0:
fi:
if not assigned(aaLossRate) then
    aaLossRate := 0:
fi:
if not assigned(invtrans) then
    invtrans := 0:
fi:
if not assigned(fissionRate) then
    fissionRate := 0:
fi:
if not assigned(fusionRate) then
    fusionRate := 0:
fi:
if not assigned(modelAssignments) then
    modelAssignments := [1]:
fi:
if not assigned(modelSwitchS) then
    modelSwitchS := [[1]]:
fi:
if not assigned(modelSwitchD) then
    modelSwitchD := [[1]]:
fi:
if not assigned(amongSiteDistr) then
    amongSiteDistr := 'None':
fi:
if not assigned(motifFreq) then
    motifFreq := 0:
fi:
if not assigned(substModels) then
    substModels := []:
fi:

if length(substModels) = 0 or not assigned(targetFreqs) then
    enableGCAmelioration := false:
else
    enableGCAmelioration := true:
fi:    

printf('setting up work directory\n'):
if length(FileStat(wdir.'/'.mname)) <> 0 then
    i := 1:
    while length(FileStat(wdir.'/'.mname.'_'.i.'/')) > 0 do
        i := i + 1:
    od:
    mname := mname.'_'.i:
fi:
wdir := wdir.'/'.mname.'/':
CallSystem('mkdir -p '.wdir):
Set(plotoutput=wdir.'/temp.ps'):

# get tree
printf('determining tree\n'):
if treeType = 'Custom' then
    if not assigned(treeFile) and not assigned(tree) then
        error('no tree given'):
    elif not assigned(tree) then
        tree := treeFile:
    fi:
    tree := CheckTree(tree):
#    tree := ReadTreeFile(treeFile):
    CheckBranchLengths(tree):
    NSpecies := 0:
    for l in Leaves(tree) do NSpecies := NSpecies + 1 od:
elif treeType = 'BDTree' then
# old code. replace with Tanja Stadler's BD-Tree sampling method
#    tree := BirthDeathTree(birthRate, deathRate, maxTime, maxSpecies, not pruneDeadLineages):
#    if pruneDeadLineages then
#        labels := ListLivingLineages(tree):
#        tree := PruneTree(tree, labels):
#    fi:
    tree := BirthDeathTree(birthRate, deathRate, NSpecies, mutRate):
    if not ultrametric then
        # create deviation using method defined in Guindon and Gascuel, 2003
        tree := AddDeviation(tree):
    fi:
elif treeType = 'ToLSample' then
    #printf('sample from tree of life\n'):
    D := GetAllDistMatrix():
    printf('generating tree with %d species\n', NSpecies):
    tree := GenRandomTree(D, NSpecies):
else
    error('no tree selected')
fi:

# calculation of the needed iteration steps
#rate := max(geneDuplRate, geneLossRate, lgtRate, lgtGRate,
#    aaGainRate, aaLossRate, 1);
if realseed = true then
    DB := ReadDb(realorganism);
    Nprot := DB[TotEntries];
    Naa := round(avg(seq(length(SearchTag('SEQ', Entry(e))), e=1..Nprot)));
else
    Naa := round(gammaLengthDist[1]*gammaLengthDist[2]);
    Nprot := protStart;
fi:
#maxSteps := max(rate * max(Naa, Nprot), 1000);

# scale tree to branch lengths matching the number of iterations
#err := traperror(ScaleTree(tree, maxSteps)):
if scaleTree then
    #print('attempting to scale tree'):
    tree := traperror(ScaleTree(tree, mutRate)); ##### NEW: scale tree to height defined in parameters #####
    if tree = lasterror then
        error('could not scale tree. make sure your tree is strictly bifurcating and all branches have a non-zero height.'):
    fi:
fi:

#print('before gc-if'):
if enableGCAmelioration then
    if length(substModels) = length(targetFreqs) then
        for i to length(targetFreqs) do
            if targetFreqs[i] = 'Random' then
                targetFreqs[i] := CreateRandomTargetFrequencies(tree, NSpecies, substModels[i][Type]):
            else
                CheckTargetFrequencies(targetFreqs[i], NSpecies, substModels[i][Type]):
            fi:
        od:    
    elif length(targetFreqs) = 1 then
        if targetFreqs[1] = 'Random' then
            targetFreqs := CreateRandomTargetFrequencies(tree, NSpecies, [seq(substModels[i][Type], i=1..length(substModels))]):
        else
            #CheckTargetFrequencies(targetFreqs[1], NSpecies, substModels[1][Type]):
            error('Please supply target frequencies for all models.'):
        fi:
    else
        error('Please supply either one set of target frequencies for all models together or for each model separately.'):
    fi:
    tree := GenInternalTargetFreqs(targetFreqs, tree):
    curTargetFreqs := CreateArray(1..NSpecies, tree[-1]):
fi:

if not webRequest then
    printf('\ntree loaded\n'):
fi:

# build list of speciation time points and nodes from the tree
res := ListTimePoints(tree, '1'):
timePts := res[1]:
timePts := sort(timePts, timePts->timePts[2]):
for i to length(timePts) do
    curprefix1 := timePts[i,1].'.1';
    curprefix2 := timePts[i,1].'.2';
    curplen := length(curprefix1);
    for j from i+1 to length(timePts) do
        if length(timePts[j,1]) >= curplen and timePts[j, 1, 1..curplen] = curprefix1 then
            timePts[j,1] := timePts[i,1].timePts[j,1,curplen+1..-1]:
        elif length(timePts[j,1]) >= curplen and timePts[j, 1, 1..curplen] = curprefix2 then
            timePts[j,1] := string(i+1).timePts[j,1,curplen+1..-1]:
        fi:
    od:
od:

for i to length(timePts) do
    timePts[i,1] := atoi(timePts[i,1]):
od:

tptransp := transpose(timePts):
specTime := tptransp[2]:
specIndex := tptransp[1]:
if length(tptransp) = 3 then specModels := tptransp[3]: fi: # model switches

# if there's a list of duplication time points prepare it
# TODO: implement this kind of duplication (for version 2?)
if res[2] <> [] then
    dupTimePts := res[2]:
    dupTimePts := sort(dupTimePts, dupTimePts->dupTimePts[2]):
    for i to length(dupTimePts) do
        curprefix1 := dupTimePts[i,1].'.1';
        curprefix2 := dupTimePts[i,1].'.2';
        curplen := length(curprefix1);
        for j from i+1 to length(dupTimePts) do
            if length(dupTimePts[j,1]) >= curplen and dupTimePts[j, 1, 1..curplen] = curprefix1 then
                dupTimePts[j,1] := dupTimePts[j,1,1].dupTimePts[j,1,curplen+1..-1]:
            elif length(dupTimePts[j,1]) >= curplen and dupTimePts[j, 1, 1..curplen] = curprefix2 then
                dupTimePts[j,1] := string(i+1).dupTimePts[j,1,curplen+1..-1]:
            fi:
        od:
    od:
    
    for i to length(dupTimePts) do
        dupTimePts[i,1] := atoi(dupTimePts[i,1]):
    od:
    
    dtptransp := transpose(dupTimePts):
    dupTime := dtptransp[2]:
    dupIndex := dtptransp[1]:
    dupModels := dtptransp[3]: # model switches
else
    dupTime := []:
    dupIndex := []:
fi:

branches := EnumerateBranches(tree, timePts, enableGCAmelioration):
branches := sort(branches, x->x[3]):

leafHeights := CreateArray(1..NSpecies, 0):
for j to length(branches) do
    org := branches[-j,1]:
    if leafHeights[org] = 0 then
        leafHeights[org] := branches[-j,3]:
    fi
od:

mutRate := max(leafHeights):

nextDupIndex := 1:
cSpecies := length(specTime) + 1:
    

if amongSiteDistr = 'Gamma' then
    gammaRates := GammaRates(alphaG, areas) / (1-motifFreq):
    gammaRates := append(gammaRates, 1/DBL_MAX):
fi:

# assign each gene a substitution model
if realseed then
    malen := DB[TotEntries]:
else
    malen := protStart:
fi:
if length(substModels) = 0 then
    modelAssignments := [seq(0, malen)]:
elif length(substModels) = 1 then
    modelAssignments := [seq(1, malen)]:
elif length(substModels) > 1 and length(modelAssignments) <> malen then
    modelProbs := modelAssignments:
    for i from 2 to length(modelProbs) do
        modelProbs[i] := modelProbs[i-1] + modelProbs[i]:
    od:
    modelAssignments := CreateArray(1..malen):
    for i to malen do
#        r := Rand():
#        for j to length(modelProbs) do
#            if r <= modelProbs[j] then
#                modelAssignments[i] := j:
#                break:
#            fi:
#        od:
        modelAssignments[i] := SearchOrderedArray(Rand()*modelProbs[-1], modelProbs) + 1:
    od:
fi:

for i to length(substModels) do
    for j from 2 to length(substModels) do
        modelSwitchS[i, j] := modelSwitchS[i, j] + modelSwitchS[i, j-1]:
        modelSwitchD[i, j] := modelSwitchD[i, j] + modelSwitchD[i, j-1]:
    od:
od:
if not webRequest then
    printf('model assignments done\n'):
fi:

# loads real genome as first organism (if realseed is selected)
if realseed = true then # generates the first organism with real data
    evolution := []:
    evolution := append(evolution, CreateArray(1..DB[TotEntries], 1..11)):
    geneR := append(geneR, CreateArray(1..DB[TotEntries]));
    for i to DB[TotEntries] do
        protseq := SearchTag('SEQ', Entry(i));
        dnaseq := SearchTag('DNA', Entry(i));
        if protseq = 'AAA' then
            if length(substModels) = 0 then
                seqLen := length(dnaseq)/blocksize:
            else
                seqLen := length(dnaseq)/susbstModels[modelAssignments[i]][Blocksize]:
            fi
        else
            seqLen := length(protseq)
        fi:
        # switch for real domainfile
        if (specialAreas = true) then
	        for j to length(areaSet[i]) do
	            areaSet[i, j, 3] := max(areaSet[i, j, 3], 1/DBL_MAX);
	        od;
            evolution[1, i, 1] := areaSet[i];
        elif length(substModels) > 0 then
            substModel := substModels[modelAssignments[i]]:
            if substModel[Name] = 'M0' then
                evolution[1, i, 1] := makeAreasOmega(substModel[Name], seqLen):
            elif substModel[Name][1] = 'M' then
                evolution[1, i, 1] := makeAreasOmega(substModel[Name], seqLen, substModel[Params][3]):
            else
                evolution[1, i, 1] := makeAreas(seqLen, areas, mutRate, amongSiteDistr, motifFreq);
            fi:
        else
            evolution[1, i, 1] := [[1, seqLen, 1]]:
        fi;
        evolution[1, i, 3] := '1';
        evolution[1, i, 4] := i;
        evolution[1, i, 5] := '1';
        evolution[1, i, 6] := dnaseq;
        if protseq = 'AAA' and ((length(substModels) > 0 and substModels[modelAssignments[i]][Type] <> 'nuc') or blocksize = 3) then
            print(evolution[1,i,6]):
            evolution[1, i, 2] := ProteinSeq(evolution[1, i, 6]):
        else
            evolution[1, i, 2] := protseq:
        fi:
        evolution[1, i, 7] := i;
        evolution[1, i, 8] := []:
        evolution[1, i, 9] := modelAssignments[i]:
        evolution[1, i, 10] := []:
        if amongGeneDistr = 'Gamma' then
            evolution[1, i, 10] := [[mutRate, Rand(GammaDist(aGAlpha))/aGAlpha]]:
        elif amongGeneDistr = 'Custom' then
            evolution[1, i, 10] := [[mutRate, customRates[i]]]:            
        fi:
        evolution[1, i, 11] := 0:
        geneR[1, i] := i;
    od:

# creates the first organism (if realseed is not selected)
else	
    evolution := []:
    evolution := append(evolution, CreateArray(1..protStart, 1..11)):
    geneR := append(geneR, CreateArray(1..protStart));
    for i to protStart do
        aaStart := max(minGeneLength, round(gammaLengthDist[2] * Rand(GammaDist(gammaLengthDist[1]))));
        if length(substModels) > 0 then
            substModel := substModels[modelAssignments[i]]:
            if substModel[Name] = 'M0' then
                evolution[1, i, 1] := makeAreasOmega(substModel[Name], aaStart):
            elif substModel[Name][1] = 'M' then
                evolution[1, i, 1] := makeAreasOmega(substModel[Name], aaStart, substModel[Params][3]):
            else
                #printf('motifs %d - ', i):
#                evolution[1, i, 1] := makeAreas(aaStart, areas, mutRate, maxSteps, amongSiteDistr, motifFreq);
                evolution[1, i, 1] := makeAreas(aaStart, areas, mutRate, amongSiteDistr, motifFreq);
            fi:
            if substModel[Type] <> 'aa' then
                if enableGCAmelioration then
                    nOfGCTargets := length(curTargetFreqs[1]):
                    bf := curTargetFreqs[1][min(nOfGCTargets, modelAssignments[i])]:
                else
                    bf := substModel[BaseFreqs]:
                fi:
                if substModel[Type] = 'nuc' and not substModel[NeutralDNA] then
                    evolution[1, i, 6] := CreateRandSeq(3*aaStart, bf);
                else
                    evolution[1, i, 6] := CreateRandSeq(aaStart, bf);
                fi:
            fi:
            if substModel[Type] = 'aa' then
                evolution[1, i, 2] := CreateRandSeq(aaStart, substModel[BaseFreqs]):
            elif substModel[Type] = 'codon' then
                evolution[1, i, 2] := ProteinSeq(evolution[1, i, 6]);
            else
                evolution[1, i, 2] := 'AAA'
            fi:
        else
            evolution[1, i, 1] := [[1, aaStart, 1]]:
            evolution[1, i, 2] := 'AAA':
            if blocksize = 1 then
                evolution[1, i, 6] := Rand(DNA(aaStart)):
            else
                dna_value := '':
                for j to aaStart do
                    do
                        curc := Rand(DNA(3)):
                        if curc <> 'TAG' and curc <> 'TGA' and curc <> 'TAA' then break: fi:
                    od:
                    dna_value := dna_value.curc:
                od:
                evolution[1, i, 6] := dna_value:
            fi:
        fi:
        evolution[1, i, 3] := '1';
        evolution[1, i, 4] := i;
        evolution[1, i, 5] := '1';
#        evolution[1, i, 7] := sprintf('%d',i);
        evolution[1, i, 7] := i;
        evolution[1, i, 8] := []:
        evolution[1, i, 9] := modelAssignments[i]:
        evolution[1, i, 10] := []:
        if amongGeneDistr = 'Gamma' then
            evolution[1, i, 10] := [[mutRate, Rand(GammaDist(aGAlpha))/aGAlpha]]:            
        fi:
        evolution[1, i, 11] := 0:
        geneR[1, i] := i;
    od:
fi:

maxID := length(evolution[1]);    # highest unique gene ID number
clusters := [seq([], maxID)]: # gene families

# definition of the GC amelioration for the first organism
#if enableGCAmelioration then
#    GCratio := append(GCratio, Rand(0.3..0.7)):
#fi:

# write out DB file of first organism
DBoutAnc(evolution[1], 1, 1, 0);

# logfile header 
lastSpeciation := 1:
print('\n\nEvolution!\n\n');
OpenWriting(wdir.'/logfile.txt'); 
lprint('Synthetic evolution\n-------------------\n');
#printf('%i iteration steps\n', maxSteps);
printf('height of tree: %a\n', mutRate);
printf('first organism (%s): %i proteins with %i aa (average)\n', 
    If(realseed = true, 'biological sequences', 'artificial sequences'), 
    Nprot, Naa);
printf('Mutation rate: %.2f, Speciations: %i\n', 
    mutRate, cSpecies);
if geneDuplRate > 0 then
    printf('Gene duplication rate: %.2f, transloc. Dupl.: %.2f\n', 
        geneDuplRate, transDupl);
fi:
if geneLossRate > 0 then
    printf('Gene loss rate: %.2f\n', geneLossRate):
fi:
if lgtRate > 0 then
    printf('LGT rate: %.2f\n', lgtRate );
fi:
if lgtGRate > 0 then
    printf('LGT rate for groups: %.2f, LGT group size: %.2f\n', lgtGRate, lgtGSize):
fi:
if invers > 0 then
    printf('Inversion rate: %.2f, max. Inversion group size: %.2f, inverted Translocation: %.2f\n',
        invers, invSize, invtrans);
fi:
if transloc > 0 then
    printf('Translocation rate: %.2f, max. Translocation group size: %.2f\n', transloc, transSize);
fi:
if aaGainRate > 0 then
    printf('aa gain rate: %.5f\n', aaGainRate);
fi:
if aaLossRate > 0 then
    printf('aa loss rate= %.5f\n', aaLossRate);
fi:
lprint():
#lprint('mutation rates: g <genenumber> : <domain 1>, <domain 2>, ...');
#for i to length(evolution[1]) do
#    printf('g %3i : ', i);
#    for j to length(evolution[1, i, 1]) do
#        printf('%.f ', evolution[1, i, 1, j, 3] * maxSteps);
#    od;
#    printf('\n');
#od;
lprint();
rateSum := geneDuplRate + geneLossRate + fusionRate + fissionRate + invers + transloc:

ngenes := [length(evolution[1])]:
curT := 0:

events := [seq([], floor(max(leafHeights)/10)+1)]:

seind := 1:
for i to length(branches) do
    if seind > 1 then
        totalRate := ngenes[branches[i,1]] * rateSum + (ngenes[branches[i,1]] + 1) * (lgtRate + lgtGRate):        
    else
        totalRate := ngenes[branches[i,1]] * rateSum:
    fi:
    #printf('rateSum: %.4g, totalRate: %.4g\n', rateSum, totalRate):
    curT := branches[i,2]:
    if enableGCAmelioration then
        curInd := floor(curT/10)+1:
        events[curInd] := append(events[curInd], [curT, branches[i,1], 'GC', branches[i, 4]]):
    fi:    
    
    if totalRate > 0 then
        do
            curInt := Rand(Exponential(0,1/totalRate)):
            if curT + curInt > branches[i,3] then break fi:
            curT := curT + curInt:
            if seind > 1 then
                # select type of event
                cumProb := copy([geneDuplRate, geneLossRate, fusionRate, fissionRate, invers, transloc, lgtRate, lgtGRate]) * ngenes[branches[i,1]]:
                cumProb[7] := cumProb[7] + lgtRate:
                cumProb[8] := cumProb[8] + lgtGRate:
            else
                cumProb := copy([geneDuplRate, geneLossRate, fusionRate, fissionRate, invers, transloc]) * ngenes[branches[i,1]]:
            fi:
            for j from 2 to length(cumProb) do
                cumProb[j] := cumProb[j-1] + cumProb[j]:
            od:
            cumProb := cumProb / cumProb[-1]:
            r := Rand():
            #printf('cumProb[1]: %.4g, r: %.4g\n', cumProb[1], r):
            event := 1:
            while r > cumProb[event] do event := event + 1 od:
    
            curInd := floor(curT/10)+1:
    
            if event = 1 then
                # gene duplication
                events[curInd] := append(events[curInd], [curT, branches[i,1], 'D']):
                ngenes[branches[i,1]] := ngenes[branches[i,1]] + 1:
                totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
            elif event = 2 then
                # gene loss
                events[curInd] := append(events[curInd], [curT, branches[i,1], 'L']):
                ngenes[branches[i,1]] := ngenes[branches[i,1]] - 1:
                totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
            elif event = 7 then
                # lgt
                events[curInd] := append(events[curInd], [curT, branches[i,1], 'LGT']):
                ngenes[branches[i,1]] := ngenes[branches[i,1]] + 1:
                totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
            elif event = 8 then
                # group lgt
                numg := Rand(2..lgtGSize):
                events[curInd] := append(events[curInd], [curT, branches[i,1], 'LGTG', numg]):
                ngenes[branches[i,1]] := ngenes[branches[i,1]] + numg:
                totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
            elif event = 3 then
                # fusion
                events[curInd] := append(events[curInd], [curT, branches[i,1], 'FU']):
                ngenes[branches[i,1]] := ngenes[branches[i,1]] - 1:
                totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
            elif event = 4 then
                # fission
                events[curInd] := append(events[curInd], [curT, branches[i,1], 'FI']):
                ngenes[branches[i,1]] := ngenes[branches[i,1]] + 1:
                totalRate := ngenes[branches[i,1]] * rateSum + lgtRate + lgtGRate:
            elif event = 5 then
                # inversion
                events[curInd] := append(events[curInd], [curT, branches[i,1], 'IV']):
            elif event = 6 then
                # transloc
                events[curInd] := append(events[curInd], [curT, branches[i,1], 'TL']):
            else
                error('unknown event!'):
            fi:
        od:
    fi:
#    printf('seind: %A, length(timePts): %A,  branches[i,1]: %A, timePts[seind,1]: %A, branches[i,3]: %A, timePts[seind,2]: %A,\n',seind, length(timePts), branches[i,1], timePts[seind,1], branches[i,3], timePts[seind,2]):
    if seind <= length(timePts) and branches[i,1] = timePts[seind,1] and branches[i,3] = timePts[seind,2] then
        ngenes := append(ngenes, copy(ngenes[branches[i,1]])):
        seind := seind + 1:
    fi: 
od:

for i to length(timePts) do
    curInd := floor(timePts[i,2]/10)+1:
    events[curInd] := append(events[curInd], [timePts[i,2], timePts[i,1], 'S']):
od:

for i to length(events) do
#    events[i] := sort(events[i], x->x[1]):
    events[i] := sort(events[i], EventOrderFunction):
od:

#if aaGainRate > 0 or aaLossRate > 0 then
#    if indelModel = 'ZIPF' then
#        meanGapLength := MeanGapLength(indelModel, maxIndelLength, [Z_c]):
#    elif indelModel = 'QG' then
#        meanGapLength := MeanGapLength(indelModel, maxIndelLength, [QG_c, QG_t]):
#    elif indelModel = 'NEGBIN' then
#        meanGapLength := MeanGapLength(indelModel, maxIndelLength, [NB_r, NB_q]):
#    elif indelModel = 'EXP' then
#    #    meanGapLength := MeanGapLength(indelModel, maxIndelLength, [E_a, E_b]):
#        meanGapLength := MeanGapLength(indelModel, maxIndelLength, [E_p]):
#    else
#        meanGapLength := MeanGapLength(indelModel, maxIndelLength, indelVector):
#    fi:
#fi:

for i to length(events) do
    for j to length(events[i]) do
        cure := events[i,j,3]:
        if cure = 'D' then
            # gene duplication
            PerformGeneDuplication(events[i,j,2], events[i,j,1], Rand(1..numberDupl)):
        elif cure = 'L' then
            # gene loss
            PerformGeneLoss(events[i,j,2], events[i,j,1]):
        elif cure = 'LGT' then
            # LGT
            PerformLGT(events[i,j,2], events[i,j,1]):
        elif cure = 'LGTG' then
            # group LGT
            PerformLGTG(events[i,j,2], events[i,j,1], events[i,j,4]):
        elif cure = 'FU' then
            # gene fusion
            PerformFusion(events[i,j,2], events[i,j,1]):
        elif cure = 'FI' then
            # gene fission
            PerformFission(events[i,j,2], events[i,j,1]):
        elif cure = 'IV' then
            # inversion
            PerformInversion(events[i,j,2]):
        elif cure = 'TL' then
            # translocation
            PerformTranslocation(events[i,j,2]):
        elif cure = 'S' then
            # speciation
            PerformSpeciation(events[i,j,2], events[i,j,1]):
        elif cure = 'GC' then
            # change of GC target content
            PerformNewGCTarget(events[i,j,2], events[i,j,1], events[i,j,4]):
        else
            error('unknown event!'):
        fi:
    od:
od:

OpenWriting(previous);


# saves real tree, updates all organisms
#printf('%A\n', treeEvo):
branchesSet := {op(branches)}:
for i to length(branchesSet) do
    treeEvo[op(treeData[branchesSet[i,1]])]:=Leaf('SE'.sprintf('%03d', branchesSet[i,1]), branchesSet[i,3], treeEvo[op(treeData[branchesSet[i,1]])][3]); 
od:
UpdateTreeLGT(treeEvo):
DrawTree(treeEvo, ArcRadial, OrderLeaves=LeftHeavy, Legend, 
    Title = 'synthetic evolution');
TimedCallSystem('mv '.wdir.'/temp.ps '.wdir.'/RealTree.ps', 2);
OpenWriting(wdir . 'RealTree.drw');
printf('RealTree := %A;\n', treeEvo);
OpenWriting(previous);
lprint('...real genome tree saved.');
OpenAppending(wdir.'/logfile.txt');
#leafHeights := CreateArray(1..livingOrgs, 0):
#for j to length(branches) do
#    org := branches[-j,1]:
for org to length(leafHeights) do
#    if leafHeights[org] = 0 then
#        leafHeights[org] := branches[-j,3]:
    g := 1:
    while g <= length(evolution[org]) do
#            seqmutation(org, g, branches[-j,3]);
        seqmutation(org, g, leafHeights[org]);
        if length(evolution[org,g,2]) = 0 and length(evolution[org,g,6]) = 0 then
            # remove genes with zero-length in the end
            gid := evolution[org,g,4]:
            grid := SearchArray(gid, abs(geneR[org])):
            geneR[org] := [op(geneR[org,1..grid-1]), op(geneR[org,grid+1..-1])]:
            evolution[org] := [op(evolution[org,1..g-1]), op(evolution[org,g+1..-1])]:
        else
            g := g+1:
        fi:
    od:
#    fi:
od:
OpenWriting(previous):
lprint('...main calculation finished.');

# calculates total number of lgt and duplication and gathers gene families
for i to livingOrgs do
    for j to length(evolution[i]) do
    	if SearchString('D', evolution[i, j, 3]) > -1 then
	        totD := totD + 1;
    	fi;
	    if SearchString('L', evolution[i, j, 3]) > -1 then
	        totL := totL + 1;
    	fi;
    	clusters[evolution[i,j,7]] := append(clusters[evolution[i,j,7]], [i,j]):
    od:
od:

# create MSAs
for i to length(clusters) do
    CreateRealMSA(clusters[i], evolution):
od:
lprint('...real MSAs written.'):

# create gene trees
#geneTrees := CreateGeneTrees(clusters, evolution, mutRate, leafHeights):
geneTrees := CreateGeneTrees(clusters, evolution, leafHeights):

# store orthologs for each pair of genes
WriteOrthologs(geneTrees, livingOrgs):

# logfile footer, DB output, GenomeSummaries
OpenAppending(wdir.'/logfile.txt');
printf('\n\n\n\%i species generated\n', livingOrgs);
if geneDuplRate > 0 then
printf('%.0f gene duplications\n', totD):
fi:
if lgtRate > 0 or lgtGRate > 0 then
    printf('%.0f lgt events\n', totL);
fi:
if enableGCAmelioration then
    printf('\nGC amelioration:');
    printf('\norganism #\ttarget GC content\tactual GC content\n'); 
    for i to NSpecies do
        printf('\norganism %i\t', i):
        for j to length(curTargetFreqs[i]) do
            printf('%.2g\t\t', ComputeTargetGCContent(curTargetFreqs[i,j])):
            if j < length(curTargetFreqs[i]) then printf(', ') fi
        od:
        printf('%.2g', calGCcont(evolution[i])); 
    od;
fi:
OpenWriting(previous);

DBout():
DBoutFASTA():
lprint('...genome DBs saved.');

if webRequest then
    summariesString := wdir.'/DB/Summaries.drw';
else
    summariesString := wdir.'/Summaries.drw':
fi:
OpenWriting(summariesString);
printf('GenomeSummaries := table():\ngenomes := []:\n');
for i to livingOrgs do
    OpenWriting(previous);
    orgname := sprintf('SE%03d', i):
    DB := ReadDb(wdir.dbdir.orgname.'.db'):
    OpenAppending(summariesString);
    printf('genomes := append(genomes, %s):\n', orgname):
    printf('GenomeSummaries[%s] :=', orgname );
    dprint(copy(GenomeSummary(DB)));
    printf(':\n');
od:
OpenWriting(previous);
lprint('\n   simulation finished!'):


# procedures for Synthetic evolution
# Daniel Margadant, CBRG, 2005
# changes: Sereina Riniker, 2006
#
# - necessary for compatibility with other algorithm (eg. LGT)
# - additional features
#

# implemented: GS[SExxx] for Synthetic Evolution organism xxx
#              GS[SExxx][TotEntries]
#              GS[SExxx][Lineage]
#              GS[SExxx][SCINAME]
#              GS[SExxx][TotLGTNum]     total number of lgt happend in history
#              GS[SExxx][TotLGT]       genes gained by lgt
#              GS[SExxx][TotDupl]         genes undergone gene duplication
#              GS[SExxx][TotDupNum]     total number of duplications happend in history
#              genomes		             
#	       GenomeFileName[genomes[j]]


ReadProgram( '/home/darwin/v2/source/bio-recipes/Orthologues/lib/darwinit' );
CreateCodonMatrices();

# mutates organisms for a certain amount of time steps, 15.12.06
seqmutation := proc(org: posint, ts: posint)
    global evolution;
    for k to length(evolution[org]) do
        seqTot := '';
        # loop over all domains for protein k
        for i to length(evolution[org, k, 1]) do
            sequence := evolution[org, k, 6][(evolution[org, k, 1][i, 1]
                * 3 - 2)..evolution[org, k, 1][i, 2] * 3];
            if GCratio[org, 2] = 'plus' then
                sequence := CodonMutate(sequence,
                    ts * evolution[org, k, 1][i, 3], GCplus);
            elif GCratio[org, 2] = 'minus' then
                sequence := CodonMutate(sequence,
                    ts * evolution[org, k, 1][i, 3], GCminus);
            fi;
            seqTot := seqTot.string(sequence);
        od;
        evolution[org, k, 6] := string(seqTot);
        evolution[org, k, 2] := ProteinSeq(evolution[org, k, 6]);
    od;
end:


## obsolete for new sets (after 11.12.06)
# counts the total number of LGTs and duplications in an organism
GenomeSummariesOld := proc(orgnumber: posint)
    global genomes, GenomeFileName;
    filepattern := 'DB/SE';
    GS := table();
    genomes := [];
    GenomeFileName := table();
    for i from 1 to orgnumber do
	totL := 0; totD := 0; totLNum := 0; totDNum := 0;
	genomes := append(genomes, 'SE'.sprintf('%03i', i));
	GenomeFileName[genomes[-1]] := wdir.filepattern.
	    sprintf('%03i', i).'.db';
	DB := ReadDb(wdir.filepattern.sprintf('%03i', i).'.db');
	t2 := table();
	for j from 1 to DB[TotEntries] do
	    e := Entry(j);
	    a := SearchTag('DE', e);
	    if SearchString('L', a) > -1 then	# searches for LGT in gene
		totL := totL + 1;
		for k to length(a) do		# counts all LGTs
		    if a[k] = 'L' then 
			totLNum := totLNum + 1;
		    fi;
		od;
	    fi;
	    if SearchString('D', SearchTag('DE', e)) > -1 then # dupl
		totD := totD + 1;
		for m to length(a) do		# counts all duplications
                    if a[m] = 'D' then 
			totDNum := totDNum + 1;
                    fi;
                od;
	    fi;
	od:
	t2[TotEntries] := DB[TotEntries];	# filling of the table
	t2[TotLGT] := totL;
	t2[TotDupl] := totD;
	t2[TotLGTNum] := totLNum;
	t2[TotDupNum] := totDNum;
	h := SearchTag('OS', DB[string]);
	t2[Lineage] := SearchDelim('-', h);
	t2[SCINAME] := genomes[-1];
	GS[genomes[-1]] := t2;
    od;
    lprint('GS done');
GS;
end:


# DB output
# 11.12.06/dm
DBout := proc()
    if FileExists(wdir.dbdir) = false then 
	    TimedCallSystem('mkdir '.wdir.dbdir, 2);
    fi;
    for i to livingOrgs do
        # header output
        orgname := sprintf('SE%03d', i);
        OpenWriting(wdir.dbdir.orgname.'.db');
        printf('<DBNAME>Synthetic organism %s</DBNAME>\n', orgname);
        printf('<DBRELEASE>SE %s</DBRELEASE>\n', mname);
        printf('<SOURCE>sequence simulation</SOURCE>\n');
        printf('<DATE>%s</DATE>\n', date());
        printf('<URL>http://www.cbrg.ethz.ch</URL>\n');
        printf('<5LETTERNAME>%s</5LETTERNAME>\n', orgname);
        printf('<SCINAME>Organismus syntheticus_%s</SCINAME>\n', orgname);
        printf('<OS>Bacteria; Syntheticales; Syntheticaceae; '.
            'Organismus syntheticus_%s</OS>\n', orgname);
        printf('<KINGDOM>Bacteria</KINGDOM>\n');
        printf('<FIELDS>ID; LOC; DE; OS; SEQ; DNA</FIELDS>\n');
        # entry output
        for j to length(evolution[i]) do
            printf('<E><ID>%a</ID><LOC>%a</LOC><DE>%a</DE><OS>%a</OS>'.
                '<SEQ>%s</SEQ><DNA>%s</DNA></E>\n',
                evolution[i, j, 4], geneR[i, j], evolution[i, j, 3], 
                evolution[i, j, 5], evolution[i, j, 2], evolution[i, j, 6]);
        od;
        OpenWriting(previous);
    od;
    lprint('\n\n.db files written...\n\n');
end:


# FASTA output
DBoutFASTA := proc()
    if FileExists(wdir.dbdir) = false then
        TimedCallSystem('mkdir '.wdir.dbdir, 2);
    fi;
    for i to livingOrgs do
        for j to length(evolution[i]) do
            OpenAppending(wdir.dbdir.'SE'.sprintf('%03d', i).'.fasta.aa');
            printf('>%a (SE%03d)\n%s\n\n', evolution[i, j, 4], i, 
                evolution[i, j, 2]);
            OpenWriting(previous);
            OpenAppending(wdir.dbdir.'SE'.sprintf('%03d', i).'.fasta.dna');
            printf('>%a (SE%03d)\n%s\n\n', evolution[i, j, 4], i,
                evolution[i, j, 6]);
            OpenWriting(previous);
        od;
    od;
    lprint('\n\n.fasta files written...\n\n');
end:


# DB output for the ancestral sequences
# 11.12.06/dm
DBoutAnc := proc(organism, parent, child, birth)
    if FileExists(wdir.dbAncdir) = false then
        TimedCallSystem('mkdir '.wdir.dbAncdir, 2);
    fi;
    orgname := sprintf('SE%i-%i(%i)', parent, child, birth);
    OpenWriting(wdir.dbAncdir.orgname.'.db');
    # header output
    printf('<DBNAME>Synthetic organism %s</DBNAME>\n', orgname);
    printf('<DBRELEASE>SE %s</DBRELEASE>\n', mname);
    printf('<SOURCE>sequence simulation</SOURCE>\n');
    printf('<DATE>%s</DATE>\n', date());
    printf('<URL>http://www.cbrg.ethz.ch</URL>\n');
    printf('<5LETTERNAME>%s</5LETTERNAME>\n', orgname);
    printf('<SCINAME>Organismus syntheticus_%s</SCINAME>\n', orgname);
    printf('<OS>Bacteria; Syntheticales; Syntheticaceae; '.
        'Organismus syntheticus_%s</OS>\n', orgname);
    printf('<KINGDOM>Bacteria</KINGDOM>\n');
    printf('<FIELDS>ID; LOC; DE; OS; SEQ; DNA</FIELDS>\n');
    # entry output
    for j to length(organism) do
        printf('<E><ID>%a</ID><LOC>%a</LOC><DE>%a</DE><OS>%a</OS><SEQ>%s</SEQ>'.
            '<DNA>%s</DNA></E>\n', organism[j, 4], geneR[i, j], organism[j, 3], 
            organism[j, 5], organism[j, 2], organism[j, 6]);
    od;
    OpenWriting(previous);
end:


# tranlates DNA to Protein (by Alexander Roth, CBRG)
ProteinSeq := proc(dna:string)
    prot := '';
    for i to length(dna) by 3 do
        prot := prot.CodonToA(dna[i..i + 2]);
    od;
end:


# gives a summary of all organism and their numbers of proteins,
# LGTs and duplications
# argument must be 'a' for array or 'r' for report
lgtReport := proc(a: string)
    summary := CreateArray(1..N,1..6);
    prot := Stat('Proteins'); lgt := Stat('LGT');
    lgtnum := Stat('LGTNum');
    dup := Stat('Dupl'); dupnum := Stat('DuplNum');
    for i to N do
        summary[i,1] := genomes[i];	
        summary[i,2] := GS[genomes[i]][TotEntries];	
        prot + summary[i][2];	
        summary[i,3] := GS[genomes[i]][TotLGT]; 
        lgt + summary[i,3];
        summary[i,4] := GS[genomes[i]][TotLGTNum]; 
        lgtnum + summary[i,4];
        summary[i,5] := GS[genomes[i]][TotDupl]; 
        dup + summary[i,5];	
        summary[i,6] := GS[genomes[i]][TotDupNum]; 
        dupnum + summary[i,6];	
    od;
    if a = 'a' then		
        result := summary;
    elif a = 'r' then
	printf('genomes\tproteins\tlgt\t\tlgt total\tdupl\t\tdupl total\n\n');
	for i to N do
	    printf('%s\t\t%i\t\t%i (%.2f%%)\t%i (%.2f%%)\t%i (%.2f%%)\t'.
            '%i (%.2f%%)\n', summary[i][1],summary[i][2],summary[i][3],
            (summary[i][3]/summary[i][2]*100),summary[i][4],
            (summary[i][4]/summary[i][2]*100),summary[i][5],
            (summary[i][5]/summary[i][2]*100),summary[i][6],
            (summary[i][6]/summary[i][2]*100));
	od;
	printf('\naverages\t%.0f\t\t%.0f (%.2f%%)\t%.0f (%.2f%%)\t'.
        '%.0f (%.2f%%)\t%.0f (%.2f%%)\n', prot[Average], lgt[Average], 
        (lgt[Average] / prot[Average] * 100), lgtnum[Average], 
        (lgtnum[Average] / prot[Average]*100), dup[Average], 
        (dup[Average] / prot[Average] * 100), dupnum[Average], 
        (dupnum[Average] / prot[Average] * 100));
	printf('mean var\t%s\t%s\t\t\t %s\n', 
        prot[MeanVar],lgt[MeanVar],dup[MeanVar]);
    else 
        printf('wrong argument, must be a or r');
    fi;
end: 


# gives a report of the ID numbers for an OMA group
lgtM := proc(omanum: posint)	# omanum = OMA number for the report
    filepattern := 'DB/SE';
    ids := CreateArray(1..N);
    for b to N do
	ids[b] := '';
    od;
    for i to N do
	DB := ReadDb(wdir.filepattern.sprintf('%03i',i).'.db');
	if M[omanum, i] = 0 then 
	    ids[i] := '0';
	    next;
	else
	    e := Entry(M[omanum,i]);
	    de := SearchTag('DE', e);
	    posL := SearchString('L', de);
	    posD := SearchString('D', de);
	    # first event was a dupl
	    if posD > -1 and (posL > posD or posL = -1) then
	    	n := posD;
           	while de[n] <> '(' do	# searches for ID number
		    n := n-1;
            	od;
                for k from (n+1) to posD do   # writes ID number
                    ids[i] := string(ids[i]).string(de[k]);
                od;
	        for j to length(de) do	# how many dupl and LGT occurred
                    if de[j] = 'L' then
			if de[j+1] = 'o' then
			    ids[i] := string(ids[i]).'Lo';
			else 
			    ids[i] := string(ids[i]).'L';
			fi;
                    elif de[j] = 'D' then ids[i] := string(ids[i]).'D';
                    fi;
                od;
	    # first event was a LGT
	    elif posL > -1 and (posD > posL or posD = -1) then
	        n := posL;
                while de[n] <> '(' do	# searches for ID number
                    n := n-1;
                od;
                for k from (n+1) to posL do  # writes ID number
                    ids[i] := string(ids[i]).string(de[k]);
                od;
	        for j to length(de) do	#  how many dupl and LGT  occured
                    if de[j] = 'L' then 
			if de[j+1] = 'o' then
                            ids[i] := string(ids[i]).'Lo';
                        else
                            ids[i] := string(ids[i]).'L';
                        fi;
                    elif de[j] = 'D' then ids[i] := ids[i].'D';
                    fi;
                od;
	    # if no LGT or duplication has occured
	    else ids[i] := SearchTag('ID', e); 
	    fi;
	fi;
    od;
    for j to N do
	printf('%s\t', genomes[j]);
    od;
    printf('\n');
    for k to N do
	printf('%s\t', string(ids[k]));
    od;
    printf('\n');
end:


# checks set of OMA number if LGT was present and gives nice summary
# useful for lgt algorithm test, 15.12.06/dm
lgtMcheck := proc(liste: set)
    realLGT := lgtGroups();	
    lgtTrue := liste intersect realLGT;
    lgtWrong := liste minus realLGT;
    lgtUnfound := realLGT minus liste;
    printf('\n\ncorrect groups:\t%i\t%.2f%%\n', length(lgtTrue),
        (length(lgtTrue) / length(realLGT) * 100));
    printf('false groups:\t%i\t%.2f%%\n', length(lgtWrong),
        (length(lgtWrong) / length(realLGT) * 100));
    printf('missed groups:\t%i\t%.2f%%\n\n', length(lgtUnfound),
        (length(lgtUnfound) / length(realLGT) * 100));
    printf('sensitivity:\t\t%.2f%%\n', length(lgtTrue) / length(realLGT) * 100);
    printf('specifity:\t\t%.2f%%\n\n', length(lgtTrue) / length(liste) * 100);
    printf('correct ones:\n%a\n', lgtTrue);
    printf('wrong ones:\n%a\n', lgtWrong);
    printf('missed ones:\n%a\n', lgtUnfound);
end:


# gives set of OMA groups in which lgt event had taken place, 15.12.06
lgtGroups := proc()
    filepattern := 'DB/SE';
    r := {};
    for i to lM do
        for j to N do
            if M[i, j] = 0 then next; fi;
            DB := ReadDb(GenomeFileName[genomes[j]]);
            if SearchString('L', SearchTag('DE', Entry(M[i, j]))) > -1 then
                r := append(r, i); 
	        fi;
	    od;	
    od;
    result := r;
end:


# gives set of OMA groups in which lgt event (orthologous replacement) had 
# taken place, 15.12.06
lgtGroupsLo := proc()
    filepattern := 'DB/SE';
    r := {};
    for i to lM do
        for j to N do
            if M[i, j] = 0 then next; fi;
            DB := ReadDb(GenomeFileName[genomes[j]]);
            if SearchString('Lo', SearchTag('DE', Entry(M[i, j]))) > -1 then
                r := append(r, i);
            fi;
        od;
    od;
    result := r;
end:


# gives an array with the names of the pairs for LGT
LGTpairs := proc(omanum: integer, spec:array)
    a := 1;
    b := lM;
    if omanum > 0 then
	a := omanum;
	b := omanum;
    fi;
    LGTrec := [];
    filepattern := 'DB/SE';    
    for i from 1 to N do        
	DB := ReadDb(wdir.filepattern.sprintf('%03i',i).'.db');
	for j from a to b do
	    if M[j,i] <> 0 then
		e := Entry(M[j,i]);
		de := SearchTag('DE', e);
		for k from 1 to length(de) do
		    donor := '': rec := '': time:=''; gene:='';
		    if de[k] = 'L' then
			n := k;
			while de[n] <> '-' do
			    n := n-1;
			od;
			n := n+1;
			while de[n] <> '(' do
			    donor := string(donor).string(de[n]);
			    n := n+1;
			od;
			n := n+1;
			while n <k do
			    gene := string(gene).string(de[n]);
			    n := n+1;
			od;
			if de[k+1] = 'o' then
			    n:= k+2;
			else
			    n := k+1;
			fi;
			while de[n] <> ')' do
			    time := string(time).string(de[n]);
			    n := n+1;
                        od;
			n := n+1;
                        while de[n] <> '-' and n < length(de) do
                            rec := string(rec).string(de[n]);
			    n := n+1;
                        od;
			if n = length(de) then
			    rec := string(rec).string(de[n]);
			fi;
			LGTrec := append(LGTrec, [genomes[parse(donor)],
			    genomes[parse(rec)],time, gene]);
		    fi;
		od;
	    fi;
	od;
    od;
    LGTrec := {op(LGTrec)};
    LGTpairs := CreateArray(1..length(LGTrec), 1..3);
    for i to length(LGTrec) do
	j := 1;
	while parse(LGTrec[i,3]) > parse(spec[j,3]) and (j+1) <= length(spec) do
	    j := j + 1;
	od;
	LGTpairs[i,1] := LGTrec[i,1];
	LGTpairs[i,2] := LGTrec[i,2];
	LGTpairs[i,3] := LGTrec[i,4].'-'.LGTrec[i,3];
	if i <> length(spec) then
	    searchSpec(i, j, LGTrec[i,1], 1, spec, LGTpairs);
	    searchSpec(i, j, LGTrec[i,2], 2, spec, LGTpairs);
	fi;
    od;
    result := LGTpairs;
end:


# searches the tree for children of the LGT parents
searchSpec := proc(i: posint, j: posint, org: string, pos: posint, spec:array, LGTpairs:array)
    for k from j to length(spec) do
	if org = spec[k,1] then
		LGTpairs[i,pos] := [op(LGTpairs[i,pos]),spec[k,2]];
	    for a from k to length(spec) do
		if spec[k,2] = spec[a,1] then
		    searchSpec(i, a, spec[k,2], pos, spec, LGTpairs);
		fi;
	    od;
	fi;                
    od;
end:


# calculates the GC content for the genome of a given organism, 15.12.06
calGCcont := proc(org)
    sumGC := 0;
    for i to length(org) do
        cont := BaseCount(org[i, 6]);
        sumGC := sumGC + ((cont[2] + cont[3]) / sum(cont[1..4]));
    od;
    return (sumGC / length(org) * 100);
end:


# generates a CodonMatrix for GC amelioration (by adrian schneider)
GCBiasMatrix := proc(bias:numeric;(lnM1=CodonLogPAM1):matrix)
M1 := exp(lnM1);
for i to 64 do for j to 64 do M1[i,j] := max(0,M1[i,j]) od od:
f := 1+bias/100;
GC := CreateArray(1..64):
for i to 64 do
    t := BaseCount(CIntToCodon(i));
    GC[i] := t[2]+t[3];
od;
for i to 64 do  # mutation from i to j
    for j to 64 do
        if j=i then next fi;
        d := GC[j]-GC[i];
        M1[j,i] := M1[j,i]*f^d;
    od;
    s := sum(M1[j,i],j=1..64)-M1[i,i];
    if s<0 or s>1 then error('invalid sum') fi;
    M1[i,i] := 1-s;
od:
return(ln(M1));
end:

# makes the areas for rate heterogenity in a gene
makeAreas := proc(aaStart, areas, mutRate, maxSteps)
    hetero := CreateArray(1..Rand(1..areas));
    numEnt := {};
    for i to (length(hetero) - 1) do
        num1 := round(aaStart / (length(hetero) - 1));
        limitlow := max(1, ((i - 1) * num1 + 1));
        limithigh := min(aaStart - 1, (i * num1 - 1));
        numEnt := append(numEnt, Rand(limitlow..limithigh));
    od;    
    numEnt := append(numEnt, 0);
    numEnt := append(numEnt, aaStart);
    for i to length(hetero) do        
	    hetero[i] := [(numEnt[i]+1), numEnt[i+1], 
            (Rand(Poisson(mutRate)) / maxSteps)];
    od;
    return(hetero);
end:

# updates the area borders after a AA gain or loss
updateBorder := proc(hetero: array, value, event: string)
    for i to length(hetero) do
	if event = 'insert' then
	   if hetero[i,1] > value then
		hetero[i,1] := (hetero[i,1] + 1);
	   fi;
	   if hetero[i,2] >= value then
		hetero[i,2] := (hetero[i,2] + 1);
	   fi;
	fi;
	if event = 'delet' then
	    if hetero[i,1] > value then
                hetero[i,1] := (hetero[i,1] - 1);
            fi;
	    if hetero[i,2] >= value then
                hetero[i,2] := (hetero[i,2] - 1);
           fi;
        fi;
   od;
   return(hetero);
end:
	
lprint('Procedures for Synthetic Evolution sucessfully loaded\n\n');

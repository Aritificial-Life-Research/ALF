# procedures for Synthetic evolution
# Daniel Margadant, CBRG, 2005
# changes: Sereina Riniker, 2006
#
# - necessary for compatibility with other algorithm (eg. LGT)
# - additional features
#

ReadProgram( '/home/darwin/v2/source/bio-recipes/Orthologues/lib/darwinit' );
CreateCodonMatrices();


########################################################################
# procedures for analyses and reports on EVA data


# counts L, Lo and D for a certain array of description strings
# needed for testM()
countEvents := proc(des:array)
    r := [];
    for i to length(des) do
        lo := length(SearchAllString('Lo', des[i]));
        l := length(SearchAllString('L', des[i])) - lo;
        d := length(SearchAllString('D', des[i]));
        r := append(r, [lo, l, d]);
    od;
    Result := r;
end:


# checks oma group for ortholog consitency, check for LGT and Paralogs
testM := proc(oma:posint)
    IDs := CreateArray(1..N);
    des := CreateArray(1..N);
    for i to N do
        if M[oma, i] = 0 then next; fi;
        DB := ReadDb(GenomeFileName[genomes[i]]);
        IDs[i] := parse(SearchTag('ID', Entry(M[oma, i])));
        des[i] := SearchTag('DE', Entry(M[oma, i]));
    od;
    s := {op(IDs)} minus {0}; s:=s[1];
    orthoFalse := [];
    printf('\n\noma[%i]\n\n', oma);
    for i to N do
        if M[oma, i] = 0 then next; fi;
        if IDs[i] = s then
            h := countEvents([des[i]]);
            printf('org: %i\tLo: %i  L: %i  D: %i\n', i, op(op(h)));
            orthoTrue := op(h);
        # a second id is present in oma
        else
            # check if id is present in another group (=paralog)
            paralog := false;
            for j to N do
                DB := ReadDb(GenomeFileName[genomes[j]]);
                for k to DB[TotEntries] do
                    if parse(SearchTag('ID', Entry(k))) = IDs[i] then
                        if SearchArray(k, transpose(M)[j]) > 0 and 
                            SearchArray(k, transpose(M)[j]) <> oma then
                            paralog := true;
                            oma2 := SearchArray(k, transpose(M)[j]); 
                        fi;
                     fi;
                 od;
            od;
            h := countEvents([des[i]]);
            if paralog = true then
                orthoFalse := append(orthoFalse, [i ,op(op(h))]);
                printf('org: %i\tLo: %i  L: %i  D: %i'.
                    '  orthologs also in M[%i]\n', i, op(op(h)), oma2);
            else
                printf('org: %i\tLo: %i  L: %i  D: %i\n', i, op(op(h)));
            fi;
        fi;
    od;
    for i to length(orthoFalse) do
        orthoFalse[i] := [orthoFalse[i, 1],
            op(orthoFalse[i][2..4] - orthoTrue)];
    od;
    Result := orthoFalse;
end:


# gives a summary of all organism and their numbers of proteins,
# LGTs and duplications, argument must be 'a' for array or 'r' for report
# !!! obsolete! (does not work on new data structure)
lgtReport := proc(a: string)
    summary := CreateArray(1..N,1..6);
    prot := Stat('Proteins'); lgt := Stat('LGT');
    lgtnum := Stat('LGTNum');
    dup := Stat('Dupl'); dupnum := Stat('DuplNum');
    for i to N do
        summary[i,1] := genomes[i];	
        summary[i,2] := GS[genomes[i]][TotEntries];	
        prot + summary[i][2];	
        summary[i,3] := GS[genomes[i]][TotLGT]; 
        lgt + summary[i,3];
        summary[i,4] := GS[genomes[i]][TotLGTNum]; 
        lgtnum + summary[i,4];
        summary[i,5] := GS[genomes[i]][TotDupl]; 
        dup + summary[i,5];	
        summary[i,6] := GS[genomes[i]][TotDupNum]; 
        dupnum + summary[i,6];	
    od;
    if a = 'a' then		
        result := summary;
    elif a = 'r' then
	printf('genomes\tproteins\tlgt\t\tlgt total\tdupl\t\tdupl total\n\n');
	for i to N do
	    printf('%s\t\t%i\t\t%i (%.2f%%)\t%i (%.2f%%)\t%i (%.2f%%)\t'.
            '%i (%.2f%%)\n', summary[i][1],summary[i][2],summary[i][3],
            (summary[i][3]/summary[i][2]*100),summary[i][4],
            (summary[i][4]/summary[i][2]*100),summary[i][5],
            (summary[i][5]/summary[i][2]*100),summary[i][6],
            (summary[i][6]/summary[i][2]*100));
	od;
	printf('\naverages\t%.0f\t\t%.0f (%.2f%%)\t%.0f (%.2f%%)\t'.
        '%.0f (%.2f%%)\t%.0f (%.2f%%)\n', prot[Average], lgt[Average], 
        (lgt[Average] / prot[Average] * 100), lgtnum[Average], 
        (lgtnum[Average] / prot[Average]*100), dup[Average], 
        (dup[Average] / prot[Average] * 100), dupnum[Average], 
        (dupnum[Average] / prot[Average] * 100));
	printf('mean var\t%s\t%s\t\t\t %s\n', 
        prot[MeanVar],lgt[MeanVar],dup[MeanVar]);
    else 
        printf('wrong argument, must be a or r');
    fi;
end: 


# gives a report of the ID numbers for an OMA group
lgtM := proc(omanum: posint)	# omanum = OMA number for the report
    filepattern := 'DB/SE';
    ids := CreateArray(1..N);
    for b to N do
	ids[b] := '';
    od;
    for i to N do
	DB := ReadDb(wdir.filepattern.sprintf('%03i',i).'.db');
	if M[omanum, i] = 0 then 
	    ids[i] := '0';
	    next;
	else
	    e := Entry(M[omanum,i]);
	    de := SearchTag('DE', e);
	    posL := SearchString('L', de);
	    posD := SearchString('D', de);
	    # first event was a dupl
	    if posD > -1 and (posL > posD or posL = -1) then
	    	n := posD;
           	while de[n] <> '(' do	# searches for ID number
		    n := n-1;
            	od;
                for k from (n+1) to posD do   # writes ID number
                    ids[i] := string(ids[i]).string(de[k]);
                od;
	        for j to length(de) do	# how many dupl and LGT occurred
                    if de[j] = 'L' then
			if de[j+1] = 'o' then
			    ids[i] := string(ids[i]).'Lo';
			else 
			    ids[i] := string(ids[i]).'L';
			fi;
                    elif de[j] = 'D' then ids[i] := string(ids[i]).'D';
                    fi;
                od;
	    # first event was a LGT
	    elif posL > -1 and (posD > posL or posD = -1) then
	        n := posL;
                while de[n] <> '(' do	# searches for ID number
                    n := n-1;
                od;
                for k from (n+1) to posL do  # writes ID number
                    ids[i] := string(ids[i]).string(de[k]);
                od;
	        for j to length(de) do	#  how many dupl and LGT  occured
                    if de[j] = 'L' then 
			if de[j+1] = 'o' then
                            ids[i] := string(ids[i]).'Lo';
                        else
                            ids[i] := string(ids[i]).'L';
                        fi;
                    elif de[j] = 'D' then ids[i] := ids[i].'D';
                    fi;
                od;
	    # if no LGT or duplication has occured
	    else ids[i] := SearchTag('ID', e); 
	    fi;
	fi;
    od;
    for j to N do
	printf('%s\t', genomes[j]);
    od;
    printf('\n');
    for k to N do
	printf('%s\t', string(ids[k]));
    od;
    printf('\n');
end:


# checks set of OMA number if LGT was present and gives nice summary
# useful for lgt algorithm test, 15.12.06/dm
lgtMcheck := proc(liste: set)
    realLGT := lgtGroups();	
    lgtTrue := liste intersect realLGT;
    lgtWrong := liste minus realLGT;
    lgtUnfound := realLGT minus liste;
    printf('\n\ncorrect groups:\t%i\t%.2f%%\n', length(lgtTrue),
        (length(lgtTrue) / length(realLGT) * 100));
    printf('false groups:\t%i\t%.2f%%\n', length(lgtWrong),
        (length(lgtWrong) / length(realLGT) * 100));
    printf('missed groups:\t%i\t%.2f%%\n\n', length(lgtUnfound),
        (length(lgtUnfound) / length(realLGT) * 100));
    printf('sensitivity:\t\t%.2f%%\n', length(lgtTrue) / length(realLGT) * 100);
    printf('specifity:\t\t%.2f%%\n\n', length(lgtTrue) / length(liste) * 100);
    printf('correct ones:\n%a\n', lgtTrue);
    printf('wrong ones:\n%a\n', lgtWrong);
    printf('missed ones:\n%a\n', lgtUnfound);
end:


# gives set of OMA groups in which lgt event had taken place, 15.12.06
lgtGroups := proc()
    r := {};
    for i to lM do
        for j to N do
            if M[i, j] = 0 then next; fi;
            DB := ReadDb(GenomeFileName[genomes[j]]);
            if SearchString('L', SearchTag('DE', Entry(M[i, j]))) > -1 then
                r := append(r, i); 
	        fi;
	    od;	
    od;
    result := r;
end:


# gives set of OMA groups in which lgt event (orthologous replacement) had 
# taken place, 15.12.06
lgtGroupsLo := proc()
    r := {};
    for i to lM do
        for j to N do
            if M[i, j] = 0 then next; fi;
            DB := ReadDb(GenomeFileName[genomes[j]]);
            if SearchString('Lo', SearchTag('DE', Entry(M[i, j]))) > -1 then
                r := append(r, i);
            fi;
        od;
    od;
    result := r;
end:

# gives array with entry and ID number of an organism in the real order
# the organism is the argument (e.g. SE001)
getGenomeOrder := proc(org:string)
    DB := ReadDb(GenomeFileName[org]);
    geneR := CreateArray(1..DB[TotEntries]);
    for i to DB[TotEntries] do
        e := Entry(i);
        loc := SearchTag('LOC', e);
        geneR[parse(loc)] := [i, SearchTag('ID', e)];   # Entry and ID number
    od;
    result := geneR;
end:

# gives array with all orthologues between two organisms as entry numbers
# arguments are the organisms (e.g. SE001)
getOrthoSet := proc(org1:string, org2:string)
    orthoSet := [];
    DB := ReadDb(GenomeFileName[org1]);
    ortho1 := CreateArray(1..DB[TotEntries]);
    for i to DB[TotEntries] do
        ortho1[i] := SearchTag('ID', Entry(i));
    od;
    DB := ReadDb(GenomeFileName[org2]);
    ortho2 := CreateArray(1..DB[TotEntries]);
    for i to DB[TotEntries] do
        ortho2[i] := SearchTag('ID', Entry(i));
    od;    
    all1 := copy(ortho1);
    all2 := copy(ortho2);
    ortho1 := {op(ortho1)};
    ortho2 := {op(ortho2)};
    a := ortho1 intersect ortho2;
    for i in a do
        orthoSet := append(orthoSet, [SearchArray(i, all1), SearchArray(i, all2)]);
    od;
    result := orthoSet;
end:

########################################################################
# internal procedures for data creation


# mutates organisms for a certain amount of time steps, 15.12.06
seqmutation := proc(org: posint, ts: posint)
    global evolution;
    for k to length(evolution[org]) do
        seqTot := '';
        # loop over all domains for protein k
        for i to length(evolution[org, k, 1]) do
            sequence := evolution[org, k, 6][(evolution[org, k, 1][i, 1]
                * 3 - 2)..evolution[org, k, 1][i, 2] * 3];
            if GCratio[org, 2] = 'plus' then
                sequence := CodonMutate(sequence,
                    ts * evolution[org, k, 1][i, 3], GCplus);
            elif GCratio[org, 2] = 'minus' then
                sequence := CodonMutate(sequence,
                    ts * evolution[org, k, 1][i, 3], GCminus);
            fi;
            seqTot := seqTot.string(sequence);
        od;
        evolution[org, k, 6] := string(seqTot);
        evolution[org, k, 2] := ProteinSeq(evolution[org, k, 6]);
    od;
end:


# DB output
# 11.12.06/dm
DBout := proc()
    if FileExists(wdir.dbdir) = false then
        TimedCallSystem('mkdir '.wdir.dbdir, 2);
    fi;
    for i to livingOrgs do
        # header output
        orgname := sprintf('SE%03d', i);
        OpenWriting(wdir.dbdir.orgname.'.db');
        printf('<DBNAME>Synthetic organism %s</DBNAME>\n', orgname);
        printf('<DBRELEASE>SE %s</DBRELEASE>\n', mname);
        printf('<SOURCE>sequence simulation</SOURCE>\n');
        printf('<DATE>%s</DATE>\n', date());
        printf('<URL>http://www.cbrg.ethz.ch</URL>\n');
        printf('<5LETTERNAME>%s</5LETTERNAME>\n', orgname);
        printf('<SCINAME>Organismus syntheticus_%s</SCINAME>\n', orgname);
        printf('<OS>Bacteria; Syntheticales; Syntheticaceae; '.
            'Organismus syntheticus_%s</OS>\n', orgname);
        printf('<KINGDOM>Bacteria</KINGDOM>\n');
        printf('<FIELDS>ID; LOC; SYNLOC; DE; OS; SEQ; DNA</FIELDS>\n');
        # entry output
        for j to length(evolution[i]) do
            loc := SearchArray(evolution[i, j, 4], abs(geneR[i]));
            if (geneR[i, loc] < 0) then
                loc := -loc;
            fi;
            printf('<E><ID>%a</ID><LOC>%a</LOC><DE>%a</DE><OS>%a</OS>'.
                '<SEQ>%s</SEQ><DNA>%s</DNA></E>\n',
                evolution[i, j, 4], loc, evolution[i, j, 3], 
                evolution[i, j, 5], evolution[i, j, 2], evolution[i, j, 6]);
        od;
        OpenWriting(previous);
    od;
    lprint('\n\n.db files written...\n\n');
end:


# FASTA output
DBoutFASTA := proc()
    if FileExists(wdir.dbdir) = false then
        TimedCallSystem('mkdir '.wdir.dbdir, 2);
    fi;
    for i to livingOrgs do
        for j to length(evolution[i]) do
            OpenAppending(wdir.dbdir.'SE'.sprintf('%03d', i).'.fasta.aa');
            printf('>%a (SE%03d)\n%s\n\n', evolution[i, j, 4], i,
                evolution[i, j, 2]);
            OpenWriting(previous);
            OpenAppending(wdir.dbdir.'SE'.sprintf('%03d', i).'.fasta.dna');
            printf('>%a (SE%03d)\n%s\n\n', evolution[i, j, 4], i,
                evolution[i, j, 6]);
            OpenWriting(previous);
        od;
    od;
    lprint('\n\n.fasta files written...\n\n');
end:


# DB output for the ancestral sequences
# 11.12.06/dm
DBoutAnc := proc(organism, parent, child, birth)
    if FileExists(wdir.dbAncdir) = false then
        TimedCallSystem('mkdir '.wdir.dbAncdir, 2);
    fi;
    orgname := sprintf('SE%i-%i_%i', parent, child, birth);
    OpenWriting(wdir.dbAncdir.orgname.'.db');
    # header output
    printf('<DBNAME>Synthetic organism %s</DBNAME>\n', orgname);
    printf('<DBRELEASE>SE %s</DBRELEASE>\n', mname);
    printf('<SOURCE>sequence simulation</SOURCE>\n');
    printf('<DATE>%s</DATE>\n', date());
    printf('<URL>http://www.cbrg.ethz.ch</URL>\n');
    printf('<5LETTERNAME>%s</5LETTERNAME>\n', orgname);
    printf('<SCINAME>Organismus syntheticus_%s</SCINAME>\n', orgname);
    printf('<OS>Bacteria; Syntheticales; Syntheticaceae; '.
        'Organismus syntheticus_%s</OS>\n', orgname);
    printf('<KINGDOM>Bacteria</KINGDOM>\n');
    printf('<FIELDS>ID; LOC; SYNLOC; DE; OS; SEQ; DNA</FIELDS>\n');
    # entry output
    for j to length(organism) do
        loc := SearchArray(organism[j, 4], abs(geneR[child]));
        if (geneR[child, loc] < 0) then
            loc := -loc;
        fi;
        printf('<E><ID>%a</ID><LOC>%a</LOC><DE>%a</DE><OS>%a</OS>'.
            '<SEQ>%s</SEQ><DNA>%s</DNA></E>\n',
            organism[j, 4], loc, organism[j, 3], organism[j, 5], 
            organism[j, 2], organism[j, 6]);
    od;
    OpenWriting(previous);
end:


# tranlates DNA to Protein (by Alexander Roth, CBRG)
ProteinSeq := proc(dna:string)
    prot := '';
    for i to length(dna) by 3 do
        prot := prot.CodonToA(dna[i..i + 2]);
    od;
end:


# gives an array with the names of the pairs for LGT
LGTpairs := proc(omanum: integer, spec:array)
    a := 1;
    b := lM;
    if omanum > 0 then
	a := omanum;
	b := omanum;
    fi;
    LGTrec := [];
    filepattern := 'DB/SE';    
    for i from 1 to N do        
	DB := ReadDb(wdir.filepattern.sprintf('%03i',i).'.db');
	for j from a to b do
	    if M[j,i] <> 0 then
		e := Entry(M[j,i]);
		de := SearchTag('DE', e);
		for k from 1 to length(de) do
		    donor := '': rec := '': time:=''; gene:='';
		    if de[k] = 'L' then
			n := k;
			while de[n] <> '-' do
			    n := n-1;
			od;
			n := n+1;
			while de[n] <> '(' do
			    donor := string(donor).string(de[n]);
			    n := n+1;
			od;
			n := n+1;
			while n <k do
			    gene := string(gene).string(de[n]);
			    n := n+1;
			od;
			if de[k+1] = 'o' then
			    n:= k+2;
			else
			    n := k+1;
			fi;
			while de[n] <> ')' do
			    time := string(time).string(de[n]);
			    n := n+1;
                        od;
			n := n+1;
                        while de[n] <> '-' and n < length(de) do
                            rec := string(rec).string(de[n]);
			    n := n+1;
                        od;
			if n = length(de) then
			    rec := string(rec).string(de[n]);
			fi;
			LGTrec := append(LGTrec, [genomes[parse(donor)],
			    genomes[parse(rec)],time, gene]);
		    fi;
		od;
	    fi;
	od;
    od;
    LGTrec := {op(LGTrec)};
    LGTpairs := CreateArray(1..length(LGTrec), 1..3);
    for i to length(LGTrec) do
	j := 1;
	while parse(LGTrec[i,3]) > parse(spec[j,3]) and (j+1) <= length(spec) do
	    j := j + 1;
	od;
	LGTpairs[i,1] := LGTrec[i,1];
	LGTpairs[i,2] := LGTrec[i,2];
	LGTpairs[i,3] := LGTrec[i,4].'-'.LGTrec[i,3];
	if i <> length(spec) then
	    searchSpec(i, j, LGTrec[i,1], 1, spec, LGTpairs);
	    searchSpec(i, j, LGTrec[i,2], 2, spec, LGTpairs);
	fi;
    od;
    result := LGTpairs;
end:


# searches the tree for children of the LGT parents
searchSpec := proc(i: posint, j: posint, org: string, pos: posint, spec:array, LGTpairs:array)
    for k from j to length(spec) do
	if org = spec[k,1] then
		LGTpairs[i,pos] := [op(LGTpairs[i,pos]),spec[k,2]];
	    for a from k to length(spec) do
		if spec[k,2] = spec[a,1] then
		    searchSpec(i, a, spec[k,2], pos, spec, LGTpairs);
		fi;
	    od;
	fi;                
    od;
end:


# calculates the GC content for the genome of a given organism, 15.12.06
calGCcont := proc(org)
    sumGC := 0;
    for i to length(org) do
        cont := BaseCount(org[i, 6]);
        sumGC := sumGC + ((cont[2] + cont[3]) / sum(cont[1..4]));
    od;
    return (sumGC / length(org) * 100);
end:


# generates a CodonMatrix for GC amelioration (by adrian schneider)
GCBiasMatrix := proc(bias:numeric;(lnM1=CodonLogPAM1):matrix)
M1 := exp(lnM1);
for i to 64 do for j to 64 do M1[i,j] := max(0,M1[i,j]) od od:
f := 1+bias/100;
GC := CreateArray(1..64):
for i to 64 do
    t := BaseCount(CIntToCodon(i));
    GC[i] := t[2]+t[3];
od;
for i to 64 do  # mutation from i to j
    for j to 64 do
        if j=i then next fi;
        d := GC[j]-GC[i];
        M1[j,i] := M1[j,i]*f^d;
    od;
    s := sum(M1[j,i],j=1..64)-M1[i,i];
    if s<0 or s>1 then error('invalid sum') fi;
    M1[i,i] := 1-s;
od:
return(ln(M1));
end:


# makes the areas for rate heterogenity in a gene
makeAreas := proc(aaStart, areas, mutRate, maxSteps)
    hetero := CreateArray(1..Rand(1..areas));
    numEnt := {};
    for i to (length(hetero) - 1) do
        num1 := round(aaStart / (length(hetero) - 1));
        limitlow := max(1, ((i - 1) * num1 + 1));
        limithigh := min(aaStart - 1, (i * num1 - 1));
        numEnt := append(numEnt, Rand(limitlow..limithigh));
    od;    
    numEnt := append(numEnt, 0);
    numEnt := append(numEnt, aaStart);
    for i to length(hetero) do        
	    hetero[i] := [(numEnt[i]+1), numEnt[i+1], 
            (Rand(Poisson(mutRate)) / maxSteps)];
    od;
    return(hetero);
end:


# updates the area borders after a AA gain or loss
updateBorder := proc(hetero: array, value, event: string)
    for i to length(hetero) do
	if event = 'insert' then
	   if hetero[i,1] > value then
		hetero[i,1] := (hetero[i,1] + 1);
	   fi;
	   if hetero[i,2] >= value then
		hetero[i,2] := (hetero[i,2] + 1);
	   fi;
	fi;
	if event = 'delet' then
	    if hetero[i,1] > value then
                hetero[i,1] := (hetero[i,1] - 1);
            fi;
	    if hetero[i,2] >= value then
                hetero[i,2] := (hetero[i,2] - 1);
           fi;
        fi;
   od;
   return(hetero);
end:


# performs the inversion of a gene group
groupInvert := proc(org: posint, target: posint, iSize: posint)
   global geneR;
   j := target + iSize -1;
   i := target;
   while j >= i do
       if j = i then
       geneR[org, i] := -geneR[org, i];
       else
       t := geneR[org, i];
           geneR[org, i] := -geneR[org, j];
           geneR[org, j] := -t;
       fi;
       i := i+1;
       j := j-1;
   od;
end:


# performs the translocation of a single gene or a gene group
transLoc := proc(org: posint, place: integer, target: posint, tSize: posint)
    global geneR;
    if place > target then
        geneR[org] := [op(geneR[org, 1..target-1]),
            op(geneR[org, target+tSize..place]),
            op(geneR[org, target..(target+tSize-1)]),
            op(geneR[org, place+1..-1])];
    elif place < target then
        geneR[org] := [op(geneR[org, 1..place]),
            op(geneR[org, target..(target+tSize-1)]),
            op(geneR[org, place+1..target-1]),
            op(geneR[org, target+tSize..-1])];
    fi;
end:


# deletes an item in the gene rearrangement array after gene loss
deleteItem := proc(org: posint, target: posint)
    global geneR;
    if target = 1 then
        geneR[org] := geneR[org, 2..-1];
    elif target = length(geneR[org]) then
        geneR[org] := geneR[org, 1..-2];
    else
        geneR[org] := [op(geneR[org, 1..(target-1)]),
        op(geneR[org, (target+1)..-1])];
    fi;
end:
  
lprint('Procedures for Synthetic Evolution sucessfully loaded\n\n');
